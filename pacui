#!/bin/bash

#  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as 
#  published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
#  =======================
#
#  Design based on IceFox script. Heavily modified by pekman, excalibur1234, Chrysostomus, papajoker, and thefallenrat.


# ANSI Escape sequences used in this script:
#  \e[31m				# red text
#  \e[36m				# cyan text
#  \e[41m				# red background
#  \e[0m	\033[0m		# non-colored, non-bold text without background color (second possiblity has to be used in "awk")
#  \e[1m	\033[1m		# bold text (second possiblity has to be used in "awk")



# all functions of pacui are defined here in the same order as they appear in pacui's UI:


function func_u 
{
		if [[ ! -e /usr/bin/pacaur ]]	# checks, whether file "pacaur" does not exist
		then
			# execute these commands, if "pacaur" is not installed on system
			sudo pacman -Syu --color always
			yaourt -Syua
		else
			# execute these commands, if "pacaur is installed on system
			pacaur -Syu  --color always
		fi
}


function func_diff 
{
		# this function is not called by pacui or pacui's UI directly. instead, it gets called in func_c when no DIFFPROG is set. it provides simple file difference viewer functionality and is essentially a wrapper around "diff". therefore, this function expects 2 arguments!
		# $(( ... )) does arithmetic evaluation. always use this when dealing with numbers, instead of strings - $[[ ... ]] does sting evaluation!

		local {temp,temp2,temp3}                                          # define local variables - these variables will be automatically deleted after the function is finished/exited.
		temp2="$( echo "$input2" | awk '{print $1}' )"                    # write second argument of "pacui diff temp2 temp3" to variable temp2. 
		temp3="$( echo "$input2" | awk '{print $2}' )"                    # write third argument of "pacui diff temp2 temp3"to variable temp3.
		temp="$(( ( $(tput cols) / 2 ) - ${#temp2} + ${#temp3} ))"        # calculates half the width of the terminal window ( $(tput cols)=width of terminal window ; ${#temp2}=width of second argument )
		
		# insert extra line with file paths above the diff viewer output:
		echo -n -e "\e[31;1m$temp2"                                       # print $temp2 (without \newline at the end) = file path of file1 . use ANSI escape sequence to print file names in this line bold and red.
		printf "%*s\n" "$temp" "$temp3"                                   # print $temp3 ( = file path of file2) with $temp number of spaces in front and \newline at the end.
		tput sgr0                                                         # printf does not support any ANSI escape sequences, so output (= red and bold text) has to be reset manually using "tput".
		
		# use "diff" as a file difference viewer with many options, which make it look good. "diff" takes 2 arguments (=the files, which are supposed to be compared)
		diff --side-by-side --suppress-common-lines --ignore-all-space --color=always --width=$(tput cols) "$temp2" "$temp3"
}


function func_m 
{
		echo "choosing fastest mirror ..."
		if [[ -e /usr/bin/pacman-mirrors ]] # checks, whether file "pacman-mirrors" does not exist
		then
			sudo pacman-mirrors -f 0 && sudo pacman -Syy                  # choose mirrors server (with up-to-date packages) with lowest ping from all available mirrors and sync database.
		fi

		if [[ -e /usr/bin/reflector ]] # checks, whether file "reflector" does not exist
		then
			sudo reflector -f 5 --sort age --save /etc/pacman.d/mirrorlist && sleep 20 && sudo pacman -Syy # If it does exists, then the mirror will sort by it
		fi
		echo ""
		
		
		echo "searching orphans ..."
		if [[ ! -e /usr/bin/pacaur ]]	# checks, whether file "pacaur" does not exist
		then
			yaourt -Qdt
		else
		
			if [[ -n $(pacman -Qdt) ]]  # only run these commands, if output of "pacman -Qdt" is not empty. this happens if there are no orphans.
			then
				
				pacman -Qdt --color always
				# ask, whether to remove the displayed orphaned packages and save answer in "answer" variable:
				read -p $'\e[1mDo you want to remove these orphaned packages? [Y|n]\e[0m' answer
				case ${answer:-y} in		# if ENTER is pressed, the variable "answer" is empty. if "answer" is empty, its default value is "y".
    				y|Y|yes|YES|Yes )		# do this, if "answer" is y or Y or yes or YES or Yes
        				sudo pacman -Rsn $(pacman -Qqdt) --color always --noconfirm
    					;;
    				* )						# do this in all other cases
        				echo "Packages have not been removed."
    					;;
				esac						# end of "case" loop

			fi
			
		fi
		echo ""


		echo "sudo pacdiff ..." 
		if [[ -n $DIFFPROG ]]     # this if-condition avoids error message when $DIFFPROG is not set/empty
		then
			sudo pacdiff
		else
			# use pacdiff to search for .pacnew and .pacsave files. display both the original and the used config file using "pacui_diff" function defined above.
			sudo DIFFPROG="pacui --diff" pacdiff
		fi
		echo ""


		if [[ -n $(sudo find -xtype l -print) ]]  # only run, if output of "sudo find -xtype l -print" is not empty
		then
			echo -e "\e[1mThe following symbolic links are broken, please fix them manually:\e[0m"
			sudo find -xtype l -print
		fi
		echo ""
		
		
		echo "checking consistency of local repository ..."
		pacman -Dk
		echo ""


		echo "checking AUR packages ..."
		# download AUR package list (only when not already downloaded), and add it to /tmp/pacui-aur-check.
		if  [[ ! -e /tmp/aur/packages.gz ]]
		then
			wget -P /tmp/aur/ https://aur.archlinux.org/packages.gz &>/dev/null
		fi
		sort -u /tmp/aur/packages.gz > /tmp/pacui-aur-check

		local pkg
		# the "comm" command compares 2 files and outputs the differences between them
		# "pacman -Qqm | sort" outputs a list of all installed packages from the AUR
		pkg=$(  comm -23 <(pacman -Qqm | sort) <(cat /tmp/pacui-aur-check)  )
		# only run the command inside the if-statement, if $pkg variable is not empty
		if [[ -n $pkg ]]
		then
			echo -e "\e[1mThe following packages are neither in your package repository nor the AUR. They will never be updated. \e[0m"
			echo -e "\e[1mUnless you know exactly what you are doing, it is recommended to remove them: \e[1m"
			echo "$pkg"
		fi
		echo ""


		if [[ $(cat /proc/1/comm) == "systemd" ]]          # if init system is systemd
		then
			echo "cleaning systemd log files ..." 
			# limit logs in journalctl to an age of 30 days and a combined size of 50mb
			sudo journalctl --vacuum-size=50M --vacuum-time=30days
		fi
		echo ""
		
		
		echo "cleaning package cache ..."
		# remove all packages, which are not installed on this system, except the latest verions (this is a back up, in case somebody removes networkmanager)
		sudo paccache -rvu -k 1
		echo ""
		# remove all package versions, except the latest 3
		sudo paccache -rv -k 3
		echo ""
		
		
		# 1. extract the name of hard drive the / partition is installed on and write it to the "disk" variatble"
		local disk		# declare local variable
		disk=$( lsblk -o "name,mountpoint" -pa | sed -n '/^\//h;/\/$/{g;p}' | cut -d/ -f3 )
		disk="${disk:0:3}"
		# 2. check, whether "disk" is not empty and whether the path to "disk" exists
		if [[ -n $disk && -e "/dev/$disk" ]]
		then
			# open the "rotational" file belonging to your "disk" and checking, whether it contains a "1" - this means your "disk" is a traditional hard drive and no SSD.
			if [[ $(cat "$( find "/sys" -name "rotational" 2>/dev/null | grep "$disk/queue" )" ) == "1" ]]
			then
			# only execute the following line when your / parition is installed on a hard drive.
			echo "sudo pacman-optimize ..." 
			sudo pacman-optimize
			echo ""
			fi
		fi
		
		
		echo "checking installed kernels ..."
		local {installed_kernels,available_kernels,eol_kernels}		# declare local variables
		installed_kernels=$( for p in `command ls -1 /boot | grep -E '^vmlinuz'`; do pacman -Qqo /boot/$p | sort; done )					# filter installed kernels from boot sector and determine, which package owns that file. this yields the package name of all installed kernels (including kernels from the AUR).
		available_kernels=$( pacman -Ssq "^linux" | grep "linux" | grep -E "^linux[0-9]*$|hardened$|lts$|zen$|rt-lts-manjaro$|rt-manjaro$" | sort )		# filter package names of kernels available in the repos for both manjaro (kernel names always like "linux414" (and rt-versions!!!)) and arch linux (these are the only kernel names (which never change): "linux", "linux-lts", "linux-hardened", "linux-zen").
		if [[ -n "$available_kernels" ]]
		then
			eol_kernels=$(comm -13 <(echo "$available_kernels") <(echo "$installed_kernels"))		# filter kernels to $eol_kernels variable, which are installed but no longer available.
			# print warning message, if end-of-life kernel(s) are found:
			if [[ -n "$eol_kernels" ]]
			then  	
				echo " "
				echo -e "\e[1mThe following Linux kernel(s) are no longer available in your repositories. \e[0m"
				echo -e "\e[1mDo not expect any security or stability fixes for the(se) kernel(s) anymore. \e[0m"
				echo -e "\e[1mKernel modules are likely to break. It is recommended to remove the kernel(s).\e[0m"
				echo -e "\e[1mIf one or more of the following kernel(s) are taken from AUR, you may safely ignore this warning. \e[0m"
				echo "$eol_kernels"
			fi
		fi
                echo ""
}


function func_i 
{
		# check, whether file /tmp/pacui-packages-install already exists (the ! negates the result)
		if  [[ ! -e /tmp/pacui-packages-install ]]
		then
			# write package list of system repositories (package name and description) to /tmp/pacui-packages-install. %-30n uses printf support in expac to format out put nicely (reserve a 32 character wide field for package name). then add all package groups to the bottom.
			# delete all spaces with "tr" (there are spaces after each package name!). this is important for installing multiple packages at the same time! command equivalent to "awk '{print $1}'"
			# awk 'NF != 0' removes all empty lines ("number of fields" in one line has to be non-zero)
			expac -S "%-33n\t%d" > /tmp/pacui-packages-install
			expac -Sg %G | sort -u | sed 's/ /\n/g' | sort -u | awk 'NF != 0' >> /tmp/pacui-packages-install
						
			# finally, download AUR package list (only when not already downloaded), and add it to the bottom of /tmp/pacui-packages-install.
			if  [[ ! -e /tmp/aur/packages.gz ]]
			then
				wget -P /tmp/aur/ https://aur.archlinux.org/packages.gz &>/dev/null
			fi
			# remove line with download date from list of AUR packages with "grep"
			# delete all spaces with "tr". this is important for installing multiple packages at the same time!
			grep -v "#" /tmp/aur/packages.gz | tr -d " " >> /tmp/pacui-packages-install
		fi
		
		local {pkg,pkg_install}
		
		# the package list in /tmp/pacui-packages-install gets sorted (by "sort" - only first column gets used for sorting) and displayed by fzf. look in "man fzf" for what fzf's arguments are used.
		# fzf lets you search and select the given list in a fast way. the "-m" flags makes it possible to select multiple list items.
		# the --preview option of fzf displays information about the currently selected line
		pkg=$( sort -k1,1 -u /tmp/pacui-packages-install | fzf-tmux -m -e +s -i -1 --query="$input2" --cycle --reverse --margin=4%,1%,1%,2% --inline-info --preview '
			if ( pacman -Qq {1} &>/dev/null )		# check, if 1. field of selected line is a locally installed package.
			then
				pacman -Qi {1} --color always
			elif ( pacman -Sgq {1} &>/dev/null )		# check, if 1. field of selected line in fzf is a package group
			then
				echo -e "\e[1m{1} group has the following members: \e[0m"
				pacman -Sgq {1}
			else									# do this if line is neither a group nor locally installed
				if [[ ! -e /usr/bin/pacaur ]]		# checks, whether file "pacaur" does not exist
				then 
					yaourt -Si {1}
				else 
					pacaur -Si {1} --color always | grep -v "::"      # grep command removes errors being displayed in pacaur
				fi
			fi
			' --preview-window=right:50%:wrap  --header="TAB key to (un)select. ENTER key to install. ESC to quit." --prompt='Enter string to filter list > ' | awk '{print $1}' )
		
		# $pkg contains package names below each other, but we need a list (in 1 line, space separated):
		pkg_install=$( echo $pkg | paste -sd " " )

		# only run the command inside the if-statement, if variable $pkg is not empty - this happens when fzf is quit with ESC or CTRL+C
		if [[ -n $pkg ]]
		then
			
			if [[ ! -e /usr/bin/pacaur ]]					# checks, whether file "pacaur" does not exist
			then
				yaourt -S $pkg_install						# !!! this command does not work when $pkg_install is quoted !!! (i do not know why)
			else
				pacaur -S $pkg_install --color always
			fi
			
		fi
}


function func_r 
{
		# write package list of local repository to /tmp/pacui-packages-group. then add all installed package groups to the bottom.
		#pacman -Qq | tr -d " " > /tmp/pacui-packages-group
		expac -Q "%-33n\t%d" > /tmp/pacui-packages-group
		# this expac command prints a list of package groups of installed packages 
		# awk 'NF != 0'  only displays lines where the number of fields is not zero (i.e. non-empty lines)
		expac -Qg %G | sort -u | sed 's/ /\n/g' | sort -u | awk 'NF != 0' >> /tmp/pacui-packages-group
		
		local {pkg,pkg_install}

		# take a sorted package (and group) list from /tmp/pacui-packages-group, then make the resulting list available to fzf.
		# fzf lets you search and select the given list in a fast way. the "-m" flags makes it possible to select multiple list items.
		pkg=$( sort -k1,1 -u /tmp/pacui-packages-group | fzf-tmux -m -e +s -i -1 --query="$input2" --cycle --reverse --margin=4%,1%,1%,2% --inline-info --preview '
			if ( pacman -Qq {1} &>/dev/null )		# check, if selected line is a locally installed package
			then
				pacman -Qi {1} --color always
			else
				echo -e "\e[1m{1} group has the following members: \e[0m"
				pacman -Sgq {1}
			fi
			' --preview-window=right:50%:wrap --header="TAB key to (un)select. ENTER key to remove. ESC to quit." --prompt='Enter string to filter list > ' | awk '{print $1}' )
        
		# $pkg contains package names below each other, but we need a list (in 1 line, space separated):
		pkg_install=$(echo $pkg | paste -sd " ")

		if [[ -n $pkg ]]	# check, whether file is non zero-size
		then
			sudo pacman -Rsn $pkg_install --color always
		fi
}



function func_t 
{
		# write package list of system repositories to /tmp/pacui-packages-local. then add all installed packages to the bottom of /tmp/pacui-packages-local.
		#pacman -Slq | tr -d " " > /tmp/pacui-packages-local
		expac -S "%-33n\t%d" > /tmp/pacui-packages-local
		#pacman -Qq | tr -d " " >> /tmp/pacui-packages-local
		expac -Q "%-33n\t%d" >> /tmp/pacui-packages-local

		local pkg

		pkg=$( sort -k1,1 -u /tmp/pacui-packages-local | fzf-tmux -e +s -i -1 --query="$input2" --cycle --reverse --margin=4%,1%,1%,2% --inline-info --preview '
			if ( pacman -Qq {1} &>/dev/null )		# check, if selected line is a locally installed package
			then
				pacman -Qi {1} --color always
			else									# do this if line is not locally installed
				if [[ ! -e /usr/bin/pacaur ]]		# checks, whether file "pacaur" does not exist
				then 
					yaourt -Si {1}
				else 
					pacaur -Si {1} --color always | grep -v "::"      # grep command removes errors being displayed in pacaur
				fi
			fi
			' --preview-window=right:50%:wrap  --header="Press ENTER to show tree. Press ESC or CTRL+C to quit." --prompt='Enter string to filter list > ' | awk '{print $1}' )

		# look in func_info for explanations
		if [[ -n $pkg ]]
		then
			if ( pacman -Qq "$pkg" &>/dev/null )
			then
				pactree -c "$pkg" | fzf-tmux -m -e +s -i --ansi --reverse --margin=4%,1%,1%,1% --inline-info --header="Dependency Tree of installed package \"$pkg\". Press ESC or CTRL+C to quit." --prompt='Enter string to filter displayed packages > ' > /tmp/pacui-t
			else
				pactree -c -s "$pkg" | fzf-tmux -m -e +s -i --ansi --reverse --margin=4%,1%,1%,1% --inline-info --header="Dependency Tree of remote package \"$pkg\". Press ESC or CTRL+C to quit." --prompt='Enter string to filter displayed packages > ' > /tmp/pacui-t
			fi
		fi
}


function func_rt 
{
		local pkg
		pkg=$( expac -Q "%-33n\t%d" | fzf-tmux -e +s -i -1 --query="$input2" --cycle --reverse --margin=4%,1%,1%,2% --inline-info --preview '
			pacman -Qi {1} --color always
			' --preview-window=right:50%:wrap  --header="Press ENTER to show reverse tree. Press ESC or CTRL+C to quit." --prompt='Enter string to filter list > ' | awk '{print $1}' )

		# look in func_info for explanations
		if [[ -n $pkg ]]
		then
			pactree -c -r "$pkg" | fzf-tmux -m -e +s -i --ansi --reverse --margin=4%,1%,1%,1% --inline-info --header="Reverse Dependency Tree of package \"$pkg\". Press ESC or CTRL+C to quit." --prompt='Enter string to filter displayed packages > ' > /tmp/pacui-rt
		fi
}


function func_l 
{
		# write package list of system repositories to /tmp/pacui-packages-local. then add all installed packages to the bottom of /tmp/pacui-packages-local.
		#pacman -Slq | tr -d " " > /tmp/pacui-packages-local
		expac -S "%-33n\t%d" > /tmp/pacui-packages-local
		#pacman -Qq | tr -d " " >> /tmp/pacui-packages-local
		expac -Q "%-33n\t%d" >> /tmp/pacui-packages-local
		
		local pkg

		pkg=$( sort -k1,1 -u /tmp/pacui-packages-local | fzf-tmux -e +s -i -1 --query="$input2" --cycle --reverse --margin=4%,1%,1%,2% --inline-info --preview '
			if ( pacman -Qq {1} &>/dev/null )		# check, if selected line is a locally installed package
			then
				pacman -Qi {1} --color always		# for local packages, "pacman" is sufficient.
			else									# do this if line is not locally installed
				if [[ ! -e /usr/bin/pacaur ]]		# checks, whether file "pacaur" does not exist
				then 
					yaourt -Si {1}
				else 
					pacaur -Si {1} --color always | grep -v "::"      # grep command removes errors being displayed in pacaur
				fi
			fi
			' --preview-window=right:50%:wrap  --header="Press ENTER to list files. Press ESC or CTRL+C to quit." --prompt='Enter string to filter list > ' | awk '{print $1}' )

		if [[ -n $pkg ]]
		then
			# next, it is checked, whether "pkg" is part of a list of all installed packages (pacman -Qq): the if-statement checks the exit code of the command "pacman -Qq $pkg &>/dev/null".
			if ( pacman -Qq "$pkg" &>/dev/null )
			then
			
				# "pacman -Ql" shows sometimes more files than "pacman -Fl". therefore, both commands have to be used!
				# take the output of command "pacman -Qlq $pkg" and make it searchable with fzf. for all used fzf flags see "man fzf". store all marked lines in file /tmp/pacui-list.
				pacman -Ql "$pkg" --color always 2>/dev/null | grep -a -v "/$" | awk '{print $NF}' | fzf-tmux -m -e +s -i --query="usr/bin/" --reverse --margin=4%,1%,1%,1% --inline-info --header="List of files of local package \"$pkg\". Press ESC or CTRL+C to quit." --prompt='Manipulate string to filter displayed file paths > ' > /tmp/pacui-l
				
			else
				
				# update local package database. this needs a long time when internet connection is slow.
				# in some cases, the local database has to be initialized with sudo pacman -Fyy
				sudo pacman -Fy
				
				# search in system repositories with "pacman -Fl" --> machine readable version of output is easier to read for awk!
				# grep -a is used, because "pacman -Fl --machinereadable" returns a file starting with non-text data. the "-a" option ignores that.
				# the awk command is used to format output: "-F '\0'" set "\0" as separator. this makes it possible to easily use $1,$2,$3,$4 as syntax later.
				# "{print $1 "/" $2 "  " $4}" prints output nicely formatted.
				pacman -Fl --machinereadable "$pkg" | grep -a -v "/$" | awk -F '\0' '{print $4}' | fzf-tmux -m -e +s -i --query="usr/bin/" --reverse --margin=4%,1%,1%,1% --inline-info --header="List of files of remote package \"$pkg\". Press ESC or CTRL+C to quit." --prompt='Manipulate string to filter displayed file paths > ' > /tmp/pacui-l
				
			fi
		fi
}


function func_s
{
		local file
		
		if [[ -n "$input2" ]]
		then
			# do this if variable "input" is not empty:
			file=$"$input2" 
		else
			# do this if pacui is used with UI or no argument is specified in "pacui s" command:
			echo "Enter (parts of) the file name to be searched (regex supported). Then press ENTER."
			read -r file
			echo
		fi
		
		if [[ -n $file ]]
		then
			
			echo -e "\n\e[1mLocal package files: \e[0m" > /tmp/pacui-search-temp
			# list all files of all installed local packages using "pacman -Ql --color always"
			# awk -v VAR="$file" '$NF ~ VAR' searches for $file (using regex) in the last field/column only. write resulting list to /tmp/pacui-search-temp
			pacman -Ql --color always | awk -v VAR="$file" -F '/' '$NF ~ VAR' >> /tmp/pacui-search-temp
			# write a list of package names (which install files containing "$file" string) to /tmp//tmp/pacui-search-temp-local
			pacman -Ql | awk -v VAR="$file" -F '/' '$NF ~ VAR' | awk -F '/' '{print $1}' | sort -u | tr -d " " > /tmp/pacui-search-temp-local

			# update local package database. this needs a long time when internet connection is slow.
			# in some cases, the local database has to be initialized with sudo pacman -Fyy
			sudo pacman -Fy


			echo -e "\n\e[1mPackage files in system repositories: \e[0m" >> /tmp/pacui-search-temp
			# search in system repositories with "pacman -Fsx" --> machine readable version of output is easier to read for awk!
			# comment: possible improvement: use "pv -ptb" to show progress bar (useful for large searches)
			# the awk command is used to format output: "-F '\0'" set "\0" as separator. this makes it possible to easily use $1,$2,$3,$4 as syntax later.

			# store raw output of "pacman -Fsx" in file /tmp/pacui-search-temp-repo, because this process is quite slow
			pacman -Fsx --machinereadable "$file" > /tmp/pacui-search-temp-repo

			# create new file /tmp/pacui-search-temp-repo2 ,which only contains package names
			cat /tmp/pacui-search-temp-repo | awk -F "\0" '{print $2}' | sort -u | tr -d " " > /tmp/pacui-search-temp-repo2

			# compare list of package names and only keep package names in system repository (in file /tmp/pacui-search-temp-repo2):
			comm -13 /tmp/pacui-search-temp-local /tmp/pacui-search-temp-repo2 > /tmp/pacui-search-temp-only-in-repo2

			# grep all package names from file /tmp/pacui-search-temp-only-in-repo2 and search for them in file /tmp/pacui-search-temp-repo
			# next, awk formats the list to the desired style
			cat "/tmp/pacui-search-temp-repo" | grep -a -f "/tmp/pacui-search-temp-only-in-repo2" | awk -F '\0' '{print  $1 "/" "\033[1m" $2 "\033[0m " $4}' >> /tmp/pacui-search-temp

			### the last command (above) is REALLY fast, but the result is much less exact than desired!!! if an exact result is needed, the following command at the end of this comment block can provide it.
			# "system( "grep -q " $2 " /tmp//tmp/pacui-search-temp-local" ) == 1" check exit status of "grep -q <package name> /tmp//tmp/pacui-search-temp-local"(checks, if <package name> is part of list /tmp//tmp/pacui-search-temp-local). if error occurs (==1), the package is printed to /tmp/pacui-search-temp
			# "{print $1 "/" $2, $4}" prints output nicely formatted to /tmp/pacui-search-temp.
			# instead of regular ANSI escape sequences, i need to use \033[1m instead of \e[1m inside the awk command.
			#pacman -Fsx --machinereadable "$file" | awk -F '\0' 'system("grep -q " $2 " /tmp//tmp/pacui-search-temp-local") == 1 {print  $1 "/" "\033[1m" $2 "\033[0m " $4}' >> /tmp/pacui-search-temp


			# display results from file /tmp/pacui-search-temp in fzf.
			cat /tmp/pacui-search-temp | fzf-tmux -m -e +s -i --ansi --reverse --margin=4%,1%,1%,1% --inline-info --header="Package file names (with path) containing \"$file\". Press ESC or CTRL+C to quit." --prompt='Enter string to filter displayed package names and file paths > ' > /tmp/pacui-s
									
		fi
}


# =======================


function func_b
{
		# declare local variables
		local {cache,cachePACAUR,pkgR,pkgI,pkgD,pkgU,line,temp1,temp2,temp3,pacui_cache_packages,pacui_cache_install,pacui_cache_downgrade,pacui_cache_downgrade_counted,pacui_tmp_downgrade,pacui_aur_install,pacui_install,pacui_downgrade,pacui_cache_upgrade,pacui_cache_upgrade_counted,pacui_tmp_upgrade,pacui_upgrade}

		# get cache directory from file /etc/pacman.conf (without any white spaces) and write results to variable $cache:
		cache=$( awk -F '=' '/^CacheDir/ {gsub(" ","",$2); print $2}' '/etc/pacman.conf' )
		# set variable $cache to default directory, if  variable $cache is empty:
		if [[ -z $cache ]]  # if "cache" variable is empty
		then
			cache="/var/cache/pacman/pkg/"
		fi
		
            if [[ -e /usr/bin/pacaur ]]		# checks, whether file "pacaur" exists, i.e. pacaur is installed
		then 
			# the cache location of pacaur is important for downgrading packages installed from the AUR or reinstalling removed pacakges from the AUR:
			if [[ -z $AURDEST ]]    # $AURDEST is environment variable for changing pacaur's default cache directory. check, if "AURDEST" variable is empty
			then
				cachePACAUR="$HOME/.cache/pacaur/"
			else
				cachePACAUR="$AURDEST"
			fi
		fi
		

		# 1. get list of last installs/upgrades/removals/downgrades from pacman log and display result in fzf. 
		# when fzf quits, only selected package names (including the words " installed/upgraded/removed/downgraded") are saved to variable $pacui_cache_packages
		#  the space in front of "installed" prevents reinstallations being displayed (otherwise, they would be removed)! the ] in "] installed" prevents config file changes being displayed, e.g. "warning: /etc/sddm.conf installed as /etc/sddm.conf.pacnew"
		pacui_cache_packages="$( tail -5000 /var/log/pacman.log | grep "\[ALPM\]" | grep "] installed\|removed\|upgraded\|downgraded" | sed 's/\[ALPM\] //g' | fzf-tmux -m -e +s -i -1 --query="$input2" --cycle --tac --reverse --margin=4%,1%,1%,2% --inline-info --header="TAB key to (un)select. ENTER key to roll back. ESC to quit." --prompt='Enter string to filter displayed list of recent Pacman changes > ' | sed 's/ ([^)]*)//g' | awk '{print $3 " " $4}' )"
		
		# only run the command inside the if-statement, if variable $pacui_cache_packages is not empty and exists - this happens when fzf is quit with ESC or CTRL+C
		if [[ ! -z "$pacui_cache_packages" ]]
		then

			
			# 2. in case of conflicting packages, packages have to be first removed (with the force option, because other packages might still depend on them).
			# filter variable $pacui_cache_packages for the word "installed" and write package names to variable $pkgR
			pkgR="$( echo "${pacui_cache_packages}" | awk '/installed/ {print $2}' | sort -u | paste -sd " " )"

			if [[ ! -z "$pkgR" ]]     # this if-condition avoids error message when no package gets removed (and $pkgR is empty)
			then
				# remove packages with pacman command. use parameter substitution with ${...} (without quotes!!!) for it, because otherwise the pacman command fails!
				sudo pacman -Rdd ${pkgR} --color always --noconfirm
			fi


			# 3. in case an "upgraded" package needs a package as dependency, the "removed" packages have to be installed.
			# filter variable $pacui_cache_packages for the word "removed" and write package names to variable $pacui_cache_install
			pacui_cache_install="$( echo "${pacui_cache_packages}" | awk '/removed/ {print $2}' )"

			if [[ ! -z "$pacui_cache_install" ]]     # this if-condition avoids error messages when no package gets installed (and variable $pacui_cache_install is empty)
			then

				if [[ -e /usr/bin/pacaur ]]		# checks, whether file "pacaur" exists, i.e. pacaur is installed
				then	
					# the while-loop here is needed to read the content of every line of $pacui_cache_install variable and save that line to variable $line.	
				    pacui_aur_install=$( while IFS='' read -r line || [[ -n "$line" ]]
				    do
						## the problem here is that AUR packages are not named/numbered in a constant and easy sortable way. therefore, we search for all files and output their modification date in an easy searchable format (and then, the file name).
						## then, "grep" is used to get only package files. then, the list is sorted (by the modification date).
						## awk gets rid of the modification date. grep filters for the file name $line. sed only chooses the first/top line.
						find "$cachePACAUR" -maxdepth 2 -mindepth 2 -type f -printf "%T+\t%p\n" | grep ".pkg.tar.[gx]z$" | sort -rn | awk '{print $2}' | grep "$line""-" | sed -n '1p'
				    done < <(echo "${pacui_cache_install}") )
				fi

				# read line by line from variable $pacui_cache_install in while loop and save that line to variable $line
				pacui_install=$( while IFS='' read -r line || [[ -n "$line" ]]
				do
					# write name of latest version in cache into file /tmp/pacui-install ("sort" puts latest version on top, which is then selected): 	
					find $cache -name "${line}-[0-9a-z.-_]*.pkg.tar.[gx]z" | sort -r | sed -n '1p'
				done < <(echo "${pacui_cache_install}") )

				# sort output to suit pacman's syntax. pacman needs a list of package names separated by single spaces.
				if [[ ! -z "$pacui_aur_install" ]]
				then
					# if AUR packages should be installed, the lists of package names are first combined before they get sorted and rearranged to space separated lists.
					# use parameter substitution to combine 2 lists of packages.
				    pkgI=$( printf "${pacui_install}\n${pacui_aur_install}" | sort -u | paste -sd " " )
				else
				    pkgI=$( echo "${pacui_install}" | sort -u | paste -sd " " )
				fi
				
				# finally, all packages get installed manually using "pacman -U":
			    if [[ ! -z "$pkgI" ]]
			    then
				    # install cannot be done as dependency, because sometimes packages are simply replaced by other packages. in this case, installing as dependency would be bad!
				    sudo pacman -U ${pkgI} --color always --noconfirm
				fi
				
			fi


			# 4. filter variable $pacui_cache_packages file for the word "upgraded" and write package names to variable $pacui_cache_downgrade
			# variable $pacui_cache_packages contains list of package names to be downgraded!
			pacui_cache_downgrade="$( echo "${pacui_cache_packages}" | awk '/upgraded/ {print $2}' )"

			if [[ ! -z "$pacui_cache_downgrade" ]]     # this if-condition avoids error messages when no package gets downgraded (and variables $pacui_cache_downgrade is empty)
			then
				
				# here, it is impossible to use variables instead of temporary files. therefore, the temporary files should be as tamper-proof as possible.
				# Create temp file with mktemp command (Important for security). the XXXXXXXX indicates numbers assigned by "mktemp" command.
				# the XXXXXXXXX numbers make it necessary to call the temporary file in the code below with ${pacui_tmp_downgrade} (without quotes)!
				pacui_tmp_downgrade=$( mktemp /tmp/pacui-tmp-downgrade.XXXXXXXX )
				
				# add trap command to immediately rm upon ctrl+c (or any other case this function quits in the middle) for security purposes
				# this is the normal syntax for "trap" command.
				trap "rm -rf ${pacui_tmp_downgrade}" EXIT
				
				# first, count the number of times the package name appears in file /tmp/pacui-cache-downgrade:
				pacui_cache_downgrade_counted="$( echo "${pacui_cache_downgrade}" | sort | uniq -c )"
				# "uniq" command: first argument in variable $pacui_cache_downgrade_counted is the number of times the package name appears and the second is the package name.
				
				# read line by line from variable $pacui_cache_downgrade_counted in while loop and save that line to variable $line
				pacui_downgrade=$( while read -r line && [[ -n "$line" ]]
				do
					
					# attention, the following variables can be empty:
					temp1=$( echo "$line" | awk '{print $1}' )   # this variable is the no. of times a package has to be downgraded
					temp2=$( echo "$line" | awk '{print $2}' )   # this variable is the package name to be downgraded

					if [[ -n $temp2 ]]   # checks, if variable is not empty
					then
						# write list with all versions of package in cache into file /tmp/pacui-temp-downgrade (sorted - newest package version is on top)
						find $cache -name "${temp2}-[0-9a-z.-_]*.pkg.tar.[gx]z" | sort -r > ${pacui_tmp_downgrade}
					      
					    if [[ -e /usr/bin/pacaur ]]		# checks, whether file "pacaur" exists, i.e. pacaur is installed
						then 
							# do the same as below for files from pacaur's cache directory.
							# the problem here is that AUR packages are not named/numbered in a constant and easy sortable way. therefore, we search for all files and output their modification date in an easy searchable format (and then, the file name).
							# then, "grep" is used to get only package files. then, the list is sorted (by the modification date).
							# awk gets rid of the modification date. grep filters for the file name $temp2.
							find "$cachePACAUR" -maxdepth 2 -mindepth 2 -type f -printf "%T+\t%p\n" | grep ".pkg.tar.[gx]z$" | sort -rn | awk '{print $2}' | grep "$temp2""-" >> ${pacui_tmp_downgrade}
						fi
						
						# temp3 is supposed to be "2p" when temp1=1 and "3p" when temp1=2 ...  --> needed for "sed" command below
						temp3="$(( temp1 + 1 ))p"
						
						# the next line moves the $((temp3-1))-th version below the currently installed package version to file /tmp/pacui-downgrade. if no such old version is available, nothing happens.
						# this command determines the currently installed verions of package $temp2:  pacman -Q "$temp2" | awk '{print $2}'
						grep "$( pacman -Q "$temp2" | awk '{print $2}' )" -A 100 "$pacui_tmp_downgrade" | sed -n "$temp3"
					fi
				
				done < <(echo "${pacui_cache_downgrade_counted}") )

				# remove temporary file. it is no longer needed an should not be left on the system.
				rm ${pacui_tmp_downgrade}

				# sort output to suit pacman's syntax. pacman needs a list of package names separated by single spaces.
				pkgD=$( echo "${pacui_downgrade}" | sort -u | paste -sd " ")
				
				# the following if-statement prevents the following error, in case there is no older package version available: "error: no targets specified (use -h for help)"
				if [[ ! -z $pkgD ]]   # checks, if variable is not empty
				then
					# downgrade packages by manually installing them: (sudo pacman -U --noconfirm --color always )
					sudo pacman -U ${pkgD} --color always --noconfirm
				fi
			
			fi


			# 5. filter variable $pacui_cache_packages file for the word "downgraded" and write package names to variable $pacui_cache_upgrade
			# variable $pacui_cache_packages contains list of package names to be downgraded!
			pacui_cache_upgrade="$( echo "${pacui_cache_packages}" | awk '/downgraded/ {print $2}' )"

			if [[ ! -z "$pacui_cache_upgrade" ]]     # this if-condition avoids error messages when no package gets upgraded (and variables $pacui_cache_upgrade is empty)
			then
				
				# here, it is impossible to use variables instead of temporary files. therefore, the temporary files should be as tamper-proof as possible.
				# Create temp file with mktemp command (Important for security). the XXXXXXXX indicates numbers assigned by "mktemp" command.
				# the XXXXXXXXX numbers make it necessary to call the temporary file in the code below with " ${pacui_cache_upgrade} " (without ")!
				pacui_tmp_upgrade=$( mktemp /tmp/pacui-tmp-upgrade.XXXXXXXX )
				
				# add trap command to immediately rm upon ctrl+c (or any other case this function quits in the middle) for security purposes
				# this is the normal syntax for "trap" command.
				trap "rm -rf ${pacui_tmp_upgrade}" EXIT
				
				# first, count the number of times the package name appears in file /tmp/pacui-cache-upgrade:
				pacui_cache_upgrade_counted="$( echo "${pacui_cache_upgrade}" | sort | uniq -c )"
				# "uniq" command: first argument in variable $pacui_cache_upgrade_counted is the number of times the package name appears and the second is the package name.

				# read line by line from variable $pacui_cache_upgrade_counted in while loop and save that line to variable $line
				pacui_upgrade=$( while read -r line && [[ -n "$line" ]]
				do
					
					# attention, the following variables can be empty:
					temp1=$( echo "$line" | awk '{print $1}' )   # this variable is the no. of times a package has to be upgraded
					temp2=$( echo "$line" | awk '{print $2}' )   # this variable is the package name to be upgraded
					
					if [[ -n $temp2 ]]   # checks, if variable is not empty
					then
						# write list with all versions of package in cache into file /tmp/pacui-temp-upgrade (sorted - newest package version is on top)
						find $cache -name "${temp2}-[0-9a-z.-_]*.pkg.tar.[gx]z" | sort -r > ${pacui_tmp_upgrade}
					      
					    if [[ -e /usr/bin/pacaur ]]		# checks, whether file "pacaur" exists, i.e. pacaur is installed
						then 
							# do the same as below for files from pacaur's cache directory.
							# the problem here is that AUR packages are not named/numbered in a constant and easy sortable way. therefore, we search for all files and output their modification date in an easy searchable format (and then, the file name).
							# then, "grep" is used to get only package files. then, the list is sorted (by the modification date).
							# awk gets rid of the modification date. grep filters for the file name $temp2.
							find "$cachePACAUR" -maxdepth 2 -mindepth 2 -type f -printf "%T+\t%p\n" | grep ".pkg.tar.[gx]z$" | sort -rn | awk '{print $2}' | grep "$temp2""-" >> ${pacui_tmp_upgrade}
						fi
						
						# temp3 is supposed to be "2p" when temp1=1 and "3p" when temp1=2 ...  --> needed for "sed" command below
						temp3="$(( temp1 + 1 ))p"
						
						# the next line moves the $((temp3-1))-th version below the currently installed package version to file /tmp/pacui-upgrade. if no such old version is available, nothing happens.
						# this command determines the currently installed verions of package $temp2:  pacman -Q "$temp2" | awk '{print $2}'
						grep "$( pacman -Q "$temp2" | awk '{print $2}' )" -B 100 "$pacui_tmp_upgrade" | tac | sed -n "$temp3"
					fi
				
				done < <(echo "${pacui_cache_upgrade_counted}") )
				
				# remove temporary file. it is no longer needed an should not be left on the system.
				rm ${pacui_tmp_upgrade}

				# sort output to suit pacman's syntax. pacman needs a list of package names separated by single spaces.
				pkgU=$( echo "${pacui_upgrade}" | sort -u | paste -sd " ")

				# the following if-statement prevents the following error, in case there is no older package version available: "error: no targets specified (use -h for help)"
				if [[ ! -z $pkgU ]]   # checks, if variable is not empty
				then
					# upgrade packages by manually installing them: (sudo pacman -U --noconfirm --color always )
					sudo pacman -U ${pkgU} --color always --noconfirm
				fi
			
			fi
			
			
		fi
}


function func_fix 
{
		echo "removing pacman database lock ..."
		sudo rm -f /var/lib/pacman/db.lck
		echo ""
		
		echo "fixing mirrors ..."
		# do this, if system uses pacman-mirrors (default in Manjaro)
		if [[ -e /usr/bin/pacman-mirrors ]]
		then 
			sudo pacman-mirrors -f 0 && sudo pacman -Syy                  # choose mirrors server (with up-to-date packages) with lowest ping from all available mirrors and sync database.
		fi
		# do this, if system uses reflector (default on Arch Linux or distributions using Arch Linux mirrors/repo servers)
		if [[ -e /usr/bin/reflector ]]
		then
			sudo reflector -f 5 --sort age --save /etc/pacman.d/mirrorlist && sleep 20 && sudo pacman -Syy
		fi
		echo ""


		# check, whether there is a connection to the mirror/repository server. this is needed for package download!
		if ( ! sudo pacman -Syy )
		then

			local server
			# extract mirror/repository server url from /etc/pacman.d/mirrorlist file:
			server=$( grep "^Server =" -m 1 /etc/pacman.d/mirrorlist | awk '{print $3}' )

  			echo -e "\e[41m Either there is something wrong with your internet connection or with your mirror/repository server: "$server" \e[0m"
			echo -e "\e[1;41m Please make sure both are ok and rerun this part of PacUI! \e[0m"
			echo -e ""

		else

			# the following command sometimes prevents an error connecting to the key server		
			echo "sudo dirmngr </dev/null ..."
			sudo dirmngr </dev/null
			echo ""


			# "SigLevel = Never" in pacman.conf lets us download and install ALL packages, even if the keyring is broken!
			echo -e "Lowering pacman securities (In case keyring is broken) ..."
			echo -e "\e[1mWARNING : LET PACUI FINISH THIS PROCESS! \e[0m"
			echo -e ""
			# This command will edit /etc/pacman.conf, and replaces all "SigLevel =" strings with "SigLevel = Never #":
			# general comment about "sed" usage in scripts: in order to avoid breakage, it is recommended to escape all the following characters /\.*[]^$ with a \ character!
			sudo sed -i 's/SigLevel[ ]*=/SigLevel = Never #/' /etc/pacman.conf


			if [[ $(cat /proc/1/comm) == "systemd" ]]          # if init system is systemd
			then
				# set almost correct time (while ignoring time zone and daylight saving time):
				# 1. stop running NTPD service (and ignore output in case NTPD is not installed):
				echo "sudo systemctl stop ntpd.service ..."
				sudo systemctl stop ntpd.service &>/dev/null
				echo ""
		
				# 2. download and install networkmanager-dispatcher-ntpd:
				echo "installing networkmanager-dispatcher-ntpd ..."
				sudo pacman -Sy networkmanager-dispatcher-ntpd --noconfirm
				echo ""

				# 3. start NTP daemon, set the system clock, and quit
				# 4. wait for 60 seconds (maximum time needed for system clock to set to new time)
				# 5. write the time from system clock to hardare clock
				sudo ntpd -qg && sleep 60 && sudo hwclock -w
				echo ""
			fi

			# remove gnupg including all keys
			echo "sudo rm -r /etc/pacman.d/gnupg ..."
			sudo rm -r /etc/pacman.d/gnupg &>/dev/null
			echo ""

			# reinstall gnupg (without keys)
			echo "Installing gnupg ..."
			sudo pacman -Sy gnupg --noconfirm
			echo ""

			echo "Installing all necessary keyrings ..."
			# This command will install all keyrings from avialable current repository
			sudo pacman -Sy $(pacman -Qsq '(-keyring)' | grep -v -i -E '(gnome|python|debian)' | paste -sd " " ) --noconfirm
			echo ""


			echo "Raising pacman securities back ..."
			# This command will revert the change from previous awk command
			sudo sed -i 's/SigLevel = Never #/SigLevel =/' /etc/pacman.conf
			echo ""


			echo "initializing and populating keyring ..."
			sudo pacman-key --init && echo "" && sudo pacman-key --populate $(pacman -Qsq '(-keyring)' | grep -v -i -E '(gnome|python|debian)' | sed 's/-keyring//' | paste -sd " " )
			echo ""
			
			#automatically trust all keys from arch linux trusted users (and manjaro developers) - both for packages from the repositories and packages fom the AUR:
			local temp
			temp=$( grep "/etc/pacman.d/gnupg/pubring.gpg" "$HOME/.gnupg/gpg.conf" )
			if [[ -n $temp ]]   # check, whether $temp variable is empty
			then
				# there are 2 different places on system for keys to be stored. move all keys for pacman to your private collection of keys. this collection is needed when installling packages from the AUR, e.g. for verifying who signed the package.
				echo "keyring /etc/pacman.d/gnupg/pubring.gpg" >> $HOME/.gnupg/gpg.conf
			fi			

			echo "cleaning pacman cache ..."
			# if keyring was broken, all non-installed (and potentially newer) packages cannot be manually installed anymore, because of key mismatch. solution: delete all non-installed packages from cache.
			sudo pacman -Sc --noconfirm
			echo ""
			
			if [[ $(cat /proc/1/comm) == "systemd" ]]          # if init system is systemd
			then
				echo "updating systemd first..."
				# updating systemd first sometimes solves update problems
				sudo pacman -S --needed --noconfirm systemd libsystemd systemd-sysvcompat && sleep 30
				echo ""
			fi
			
			echo "updating system ..."
			sudo pacman -Syyuu --color always --noconfirm
			echo ""
			sudo pacman -Suu --color always
			echo ""
			sudo pacman -Fyy

		fi
}


function func_c 
{
		# create file, which will contain a list of strings
		touch /tmp/pacui-conf
        
		# if file /etc/default/tlp exists, push string "/etc/default/tlp              - Configure power management." into /tmp/pacui-conf file.
		[[ -e /etc/default/tlp ]]                  && echo -e "/etc/default/tlp                  - Configure power management." >> /tmp/pacui-conf
		[[ -e /etc/default/cpupower ]]             && echo -e "/etc/default/cpupower             - Configure CPU power management." >> /tmp/pacui-conf
		[[ -e /etc/profile.d/freetype2.sh ]]       && echo -e "/etc/profile.d/freetype2.sh       - Configure TrueType interpreter, including Infinality mode." >> /tmp/pacui-conf
		[[ -e /etc/pulse/daemon.conf ]]            && echo -e "/etc/pulse/daemon.conf            - Configure PulseAudio daemon." >> /tmp/pacui-conf
		[[ -e /etc/pacman.conf ]]                  && echo -e "\e[31m/etc/pacman.conf                  - Configure Pacman.\e[0m" >> /tmp/pacui-conf
		[[ -e /etc/pacman-mirrors.conf ]]          && echo -e "/etc/pacman-mirrors.conf          - Configure Manjaro's pacman-mirrors." >> /tmp/pacui-conf
		[[ -e /etc/pacman.d/mirrorlist ]]          && echo -e "/etc/pacman.d/mirrorlist          - Configure mirror list manually." >> /tmp/pacui-conf
		[[ -e /etc/yaourtrc ]]                     && echo -e "/etc/yaourtrc                     - Configure Yaourt." >> /tmp/pacui-conf
		[[ -e $XDG_CONFIG_DIRS/pacaur/config ]]    && echo -e "$XDG_CONFIG_DIRS/pacaur/config            - Configure Pacaur." >> /tmp/pacui-conf
		[[ -e /etc/makepkg.conf ]]                 && echo -e "/etc/makepkg.conf                 - Configure package compilation." >> /tmp/pacui-conf
		[[ -e /etc/resolv.conf ]]                  && echo -e "/etc/resolv.conf                  - Configure DNS servers." >> /tmp/pacui-conf
		[[ -e /etc/hostname ]]                     && echo -e "/etc/hostname                     - Configure your network hostname" >> /tmp/pacui-conf
		[[ -e /etc/hosts ]]                        && echo -e "/etc/hosts                        - Configure local DNS." >> /tmp/pacui-conf
		[[ -e /etc/environment ]]                  && echo -e "/etc/environment                  - Configure system-wide environment variables." >> /tmp/pacui-conf
		[[ -e /etc/slim.conf ]]                    && echo -e "/etc/slim.conf                    - Configure slim display manager." >> /tmp/pacui-conf
		[[ -e /etc/lightdm.conf ]]                 && echo -e "/etc/lightdm.conf                 - Configure lightdm display manager." >> /tmp/pacui-conf
		[[ -e /etc/sddm.conf ]]                    && echo -e "/etc/sddm.conf                    - Configure sddm display manager." >> /tmp/pacui-conf
		[[ -e /etc/mdm/mdm.conf ]]                 && echo -e "/etc/mdm/mdm.conf                 - Configure mdm display manager." >> /tmp/pacui-conf
		[[ -e /etc/lxdm/lxdm.conf ]]               && echo -e "/etc/lxdm/lxdm.conf               - Configure lxdm display manager." >> /tmp/pacui-conf
		[[ -e /etc/gdm/custom.conf ]]              && echo -e "/etc/gdm/custom.conf              - Configure gdm display manager." >> /tmp/pacui-conf
		[[ -e /etc/entrance/entrance.conf ]]       && echo -e "/etc/entrance/entrance.conf       - Configure entrance display manager." >> /tmp/pacui-conf
		[[ -e /etc/conf.d/xdm ]]                   && echo -e "/etc/conf.d/xdm                   - Configure xdm display manager." >> /tmp/pacui-conf
		[[ -e $HOME/.bashrc ]]                     && echo -e "~/.bashrc                         - Configure bash shell." >> /tmp/pacui-conf
		[[ -e $HOME/.zshrc ]]                      && echo -e "~/.zshrc                          - Configure zsh shell." >> /tmp/pacui-conf
		[[ -e $HOME/.config/fish ]]                && echo -e "~/.config/fish/*                  - Configure fish shell." >> /tmp/pacui-conf
		[[ -e $HOME/.xinitrc ]]                    && echo -e "\e[31m~/.xinitrc                        - Configure X server startup.\e[0m" >> /tmp/pacui-conf
		[[ -e $HOME/.Xresources ]]                 && echo -e "\e[31m~/.Xresources                     - Configure X client applications.\e[0m" >> /tmp/pacui-conf
		[[ -e /etc/fstab ]]                        && echo -e "\e[31m/etc/fstab                        - Configure file system mount table.\e[0m" >> /tmp/pacui-conf
		[[ -e /etc/crypttab ]]                     && echo -e "\e[31m/etc/crypttab                     - Configure encrypted file system mount table.\e[0m" >> /tmp/pacui-conf
		[[ -e /etc/sudoers ]]                      && echo -e "\e[31m/etc/sudoers                      - Configure sudo.\e[0m" >> /tmp/pacui-conf
		[[ -e /etc/systemd/swap.conf ]]            && echo -e "/etc/systemd/swap.conf            - Configure systemd swap." >> /tmp/pacui-conf
		[[ -e /etc/systemd/logind.conf ]]          && echo -e "/etc/systemd/logind.conf          - Configure systemd user logins." >> /tmp/pacui-conf
		[[ -e /etc/systemd/journald.conf ]]        && echo -e "/etc/systemd/journald.conf        - Configure systemd logging." >> /tmp/pacui-conf
		[[ -e /etc/systemd/coredump.conf ]]        && echo -e "/etc/systemd/coredump.conf        - Configure systemd coredumps." >> /tmp/pacui-conf
		[[ -e /etc/systemd/system.conf ]]          && echo -e "/etc/systemd/system.conf          - Configure systemd system." >> /tmp/pacui-conf
		[[ -e /usr/lib/systemd/system  ]]          && echo -e "/usr/lib/systemd/system/*.service - Configure all systemd services in user directory." >> /tmp/pacui-conf
		[[ -e /usr/lib/systemd/system  ]]          && echo -e "/usr/lib/systemd/system/*.timer   - Configure all systemd timers in user directory." >> /tmp/pacui-conf
		[[ -e /etc/X11/xorg.conf.d ]]              && echo -e "\e[31m/etc/X11/xorg.conf.d/*            - Configure Xorg display server in multiple files.\e[0m" >> /tmp/pacui-conf
		[[ -e $HOME/.config/weston.ini ]]          && echo -e "~/.config/weston.ini              - Configure Weston compositor." >> /tmp/pacui-conf
		[[ -e /etc/sysctl.d ]]                     && echo -e "/etc/sysctl.d/*                   - Configure kernel parameters at runtime in multiple files." >> /tmp/pacui-conf
		[[ -e /etc/mkinitcpio.conf ]]              && echo -e "\e[31m/etc/mkinitcpio.conf              - Configure initial ramdisk environment.\e[0m" >> /tmp/pacui-conf
		[[ -e /etc/default/grub ]]                 && echo -e "\e[31m/etc/default/grub                 - Configure GRUB boot loader.\e[0m" >> /tmp/pacui-conf
		[[ -e /boot/loader/loader.conf ]]          && echo -e "\e[31m/boot/loader/loader.conf          - Configure systemd-boot boot loader.\e[0m" >> /tmp/pacui-conf
		[[ -e /boot/loader/entries ]]              && echo -e "\e[31m/boot/loader/entries/*.conf       - Configure systemd-boot boot loader entries.\e[0m" >> /tmp/pacui-conf
		[[ -e /boot/refind_linux.conf ]]           && echo -e "\e[31m/boot/refind_linux.conf           - Configure rEFInd boot loader.\e[0m" >> /tmp/pacui-conf
		[[ -e /boot/EFI/refind/refind.conf ]]      && echo -e "\e[31m/boot/EFI/refind/refind.conf      - Configure rEFInd boot loader.\e[0m" >> /tmp/pacui-conf
		[[ -e /boot/EFI/CLOVER/config.plist ]]     && echo -e "\e[31m/boot/EFI/CLOVER/config.plist     - Configure Clover boot loader.\e[0m" >> /tmp/pacui-conf
		[[ -e /boot/syslinux/syslinux.cfg ]]       && echo -e "\e[31m/boot/syslinux/syslinux.cfg       - Configure syslinux boot loaders.\e[0m" >> /tmp/pacui-conf
		
		local file

		# echo -e "$( cat '/tmp/pacui-conf' )"  -- this command interprets the ANSI escape sequences contained in /tmp/pacui-conf.
		file=$( echo -e "$( cat '/tmp/pacui-conf' )" | fzf-tmux -e +s -i -1 --ansi --cycle --query="$input2" --reverse --margin=4%,1%,1%,2% --inline-info --header="Press ENTER to edit file. Press ESC or CTRL+C to quit." --prompt='Enter string to filter displayed list of files > ' | awk '{print $1}' )
		
		# only run the command inside the if-statement, if $file variable is not empty <-- this happens when fzf is quit with ESC or CTRL+C
		if [[ -n $file ]]
		then
			if [[ $( echo $file | cut -c1 ) == "~" ]]
			# if "file"'s first character is a "~" (tilde), the "file" should NOT be opened as root!
			then
				# if $EDITOR variable does not exist, set it to 'nano'
				[[ -z "$EDITOR" ]] && EDITOR='nano'
				# open "file" in "EDITOR": (attention: "$file" (including " symbols) does NOT WORK!!!, but strangely $file (without " symbols") works fine.)
				$EDITOR $file
			elif [[ $file == "/etc/sudoers" ]]
			then
				# the sudoers file should never be edited directly! if something goes wrong, sudo stops working. instead, visudo should be used. this is much safer.
				sudo EDITOR=nano visudo
			elif [[ $file == "/etc/pacman.d/mirrorlist" ]] || [[ $file == "/etc/pacman-mirrors.conf" ]]
			then
				# if $EDITOR variable does not exist, set it to 'nano'
				[[ -z "$EDITOR" ]] && EDITOR='nano'
				# open "file" in "EDITOR": (attention: "$file" (including " symbols) does NOT WORK!!!)
				sudo $EDITOR $file
				sudo pacman -Syy                                                     # apply changes
			elif [[ $file == "/etc/fstab" ]]
			then
				# if $EDITOR variable does not exist, set it to 'nano'
				[[ -z "$EDITOR" ]] && EDITOR='nano'
				# open "file" in "EDITOR": (attention: "$file" (including " symbols) does NOT WORK!!!)
				sudo $EDITOR $file
				sudo mount -a	                                                     # mount all drives/partitions in /etc/fstab file. this shows immediately mistakes in your /etc/fstab file and prevents non-working systems.
			elif [[ $file == "/etc/mkinitcpio.conf" ]]
			then
				[[ -z "$EDITOR" ]] && EDITOR='nano'
				sudo $EDITOR $file
				sudo mkinitcpio -P && sudo grub-mkconfig -o /boot/grub/grub.cfg      # apply changes   # "grub-mkconfig -o /boot/grub/grub.cfg" == "udpate-grub" (in manjaro)
			elif [[ $file == "/etc/default/grub" ]]
			then
				[[ -z "$EDITOR" ]] && EDITOR='nano'
				sudo $EDITOR $file
				sudo grub-mkconfig -o /boot/grub/grub.cfg                            # apply changes   # "grub-mkconfig -o /boot/grub/grub.cfg" == "udpate-grub" (in manjaro)
			else
				# start "sudo nano $file" for all other files (not mentioned separately in elif-statements above)
				[[ -z "$EDITOR" ]] && EDITOR='nano'
				sudo $EDITOR $file
			fi
		fi
		rm /tmp/pacui-conf
}



function func_fu 
{
		sudo pacman -Syu --force --color always
}


function func_e 
{
		if [[ ! -e /usr/bin/pacaur ]]	             # checks, whether file "pacaur" does not exist
		then
			yaourt -Scc
		else
			pacaur -Scc --color always
		fi
}


function func_fi 
{
		# check, whether file /tmp/pacui-packages-group-repo already exists (the ! negates the result)
		if [[ ! -e /tmp/pacui-packages-group-repo ]]
		then
			# write formatted package list of repositories to /tmp/pacui-packages-group-repo. then add all package groups to the bottom.
			#pacman -Slq | tr -d " " > /tmp/pacui-packages-group-repo
			expac -S "%-33n\t%d"  > /tmp/pacui-packages-group-repo
			#pacman -Sg | tr -d " " >> /tmp/pacui-packages-group-repo
			expac -Sg %G | sort -u | sed 's/ /\n/g' | sort -u | awk 'NF != 0' >> /tmp/pacui-packages-group-repo
		fi
		
		local {pkg,pkg_install}

		# take a sorted package (and group) list from /tmp/pacui-packages-group, then make the resulting list available to fzf.
		# fzf lets you search and select the given list in a fast way. the "-m" flags makes it possible to select multiple list items.
		# the --preview option of fzf displays information about the currently selected line
		pkg=$( sort -k1,1 -u /tmp/pacui-packages-group-repo | fzf-tmux -m -e +s -i -1 --query="$input2" --cycle --reverse --margin=4%,1%,1%,2% --inline-info --preview '
			if ( pacman -Qq {1} &>/dev/null )		# check, if selected line is a locally installed package
			then
				pacman -Qi {1} --color always
			elif ( pacman -Sgq {1} &>/dev/null )		# check, if selected line in fzf is a package group
			then
				echo -e "\e[1m{1} group has the following members: \e[0m"
				pacman -Sgq {1}
			else									# do this if line is neither a group nor locally installed
				if [[ ! -e /usr/bin/pacaur ]]		# checks, whether file "pacaur" does not exist
				then 
					yaourt -Si {1}
				else 
					pacaur -Si {1} --color always | grep -v "::"      # grep command removes errors being displayed in pacaur
				fi
			fi
			' --preview-window=right:50%:wrap  --header="TAB key to (un)select. ENTER key to install. ESC to quit." --prompt='Enter string to filter list > ' | awk '{print $1}' )
		
		# $pkg contains package names below each other, but we need a list (in 1 line, space separated):
		pkg_install=$(echo $pkg | paste -sd " ")
		
		if [[ -n $pkg ]]		# check, whether variable $pkg is empty - this happens when fzf is quit with ESC or CTRL+C
		then
			sudo pacman -S --force $pkg_install --color always
		fi
}


function func_fr 
{
		# write package list of local repository to /tmp/pacui-packages-group. then add all installed package groups to the bottom.
		#pacman -Qq | tr -d " " > /tmp/pacui-packages-group
		expac -Q "%-33n\t%d"  > /tmp/pacui-packages-group
		# this expac command prints a list of package groups of installed packages 
		# awk 'NF != 0'  only displays lines where the number of fields is not zero (i.e. non-empty lines)
		expac -Qg %G | sort -u | sed 's/ /\n/g' | sort -u | awk 'NF != 0' | tr -d " " >> /tmp/pacui-packages-group

		local {pkg,pkg_install}

		# take a sorted package (and group) list from /tmp/pacui-packages-group, then make the resulting list available to fzf.
		# fzf lets you search and select the given list in a fast way. the "-m" flags makes it possible to select multiple list items.
		# the --preview option of fzf displays information about the currently selected line
		pkg=$( sort -k1,1 -u /tmp/pacui-packages-group | fzf-tmux -m -e +s -i -1 --query="$input2" --cycle --reverse --margin=4%,1%,1%,2% --inline-info --preview '
			if ( pacman -Qq {1} &>/dev/null )		# check, if selected line is a locally installed package
			then
				pacman -Qi {1} --color always
			else
				echo -e "\e[1m{1} group has the following members: \e[0m"
				pacman -Sgq {1}
			fi
			' --preview-window=right:50%:wrap --header="TAB key to (un)select. ENTER key to remove. ESC to quit." --prompt='Enter string to filter list > ' | awk '{print $1}' )
		
		# $pkg contains package names below each other, but we need a list (in 1 line, space separated):
		pkg_install=$(echo $pkg | paste -sd " ")

		if [[ -n $pkg ]]
		then
			sudo pacman -Rdd $pkg_install --color always
		fi
}


# =======================


function func_ua 
{
		if [[ ! -e /usr/bin/pacaur ]]	          # checks, whether file "pacaur" does not exist
		then
			yaourt -Syua && yaourt -Syua --devel --needed --noconfirm
		else
			pacaur -Syua --color always && pacaur -Syua --devel --needed --color always
		fi		
}


function func_la 
{
		# this command shows all packages from external, i.e. not in system repositories, sources:
		# packages from the AUR and manually installed packages
		# "pacman -Qm --color always"
		pacman -Qqm --color always | fzf-tmux -m -e +s -i --cycle --ansi --reverse --margin=4%,1%,1%,2% --inline-info --preview '
			pacman -Qi {} --color always
			' --preview-window=right:50%:wrap  --header="List of AUR and manually installed packages. Press ESC or CTRL+C to quit." --prompt='Enter string to filter list > ' > /tmp/pacui-la



}


# =======================
# the following functions are hidden in the UI.


function func_ls
{
		# list all packages on local system sorted by their installed size using "expac" and "sort".
		# $( comm -23 <(pacman -Qq | sort) <(pacman -Qqg base base-devel | sort) )  only shows packages, which are not part of "base" or "base-devel" group.
		expac -H M -Q '%12m - \e[1m%n\e[0m %v' $( comm -23 <(pacman -Qq | sort) <(pacman -Qqg base base-devel | sort) ) | sort -n -r | fzf-tmux -m -e +s -i --ansi --reverse --margin=4%,1%,1%,1% --inline-info --header="Navigate with PageUp / PageDown Keys. Press ESC or CTRL+C to quit." --prompt='Enter string to filter displayed packages > ' > /tmp/pacui-ls	
		# alternative command to "expac" and "sort": package-query -Qe --rsort 2 -f "%2 - \e[1m%n \e[0m%v" | numfmt --to=iec 
}


function func_d
{
		# write package list of system repositories to /tmp/pacui-packages-local. then add all installed packages to the bottom of /tmp/pacui-packages-local.
		pacman -Slq | tr -d " " > /tmp/pacui-packages-local
		pacman -Qq | tr -d " " >> /tmp/pacui-packages-local
		
		local pkg
		local pkg_install

		pkg=$( sort -k1,1 -u /tmp/pacui-packages-local | fzf-tmux -m -e +s -i -1 --query="$input2" --cycle --reverse --margin=4%,1%,1%,2% --inline-info --header="TAB key to (un)select. ENTER key to downgrade. ESC to quit." --prompt='Enter string to filter displayed list of packages > ' | awk '{print $1}' )
		
		# $pkg contains package names below each other, but we need a list (in 1 line, space separated):
		pkg_install=$(echo $pkg | paste -sd " ")

		if [[ -n $pkg ]]
		then
			downgrade $pkg_install
		fi
}


function func_a 
{
		local pkg
		
		if [[ -n "$input2" ]]
		then
		
			if [[ ! -e /usr/bin/pacaur ]]	      # checks, whether file "pacaur" does not exist
			then
				# do this if variable "input" is not empty:
				yaourt "$input2"
			else
				pacaur -Ss "$input2" --color always | grep -v "::"      # grep command removes errors being displayed in pacaur
			fi				
				
		else
			
			# do this if pacui is used with UI or no argument is specified in "pacui a" command:
			echo "Enter (parts of) name and/or description of package to be searched. Then press ENTER."
			read -r pkg
            
			if [[ ! -e /usr/bin/pacaur ]]	      # checks, whether file "pacaur" does not exist
			then
				yaourt "$pkg"
			else
				pacaur -Ss "$pkg" --color always | grep -v "::"      # grep command removes errors being displayed in pacaur
			fi
			
		fi
}


# =======================


function func_h
{
		# the "then" part is displayed, when started directly from terminal (the last function adds the "1" parameter). the "else" part gets displayed when started from UI.
		if [[ "$1" == "1" ]]
		then

			echo
			echo -e "  pacui	      - \e[1mPacUI\e[0m with User Interface"
			echo
			echo -e "  pacui	u     - \e[1mU\e[0mpdate System"
			echo -e "  pacui	m     - \e[1mM\e[0maintain System"
			echo -e "  pacui	i     - \e[1mI\e[0mnstall Packages"
			echo -e "  pacui	r     - \e[1mR\e[0memove Packages + Deps"
			echo -e "  pacui	t     - Dependency \e[1mT\e[0mree"
			echo -e "  pacui	rt    - \e[1mR\e[0meverse Dependency \e[1mT\e[0mree"
			echo -e "  pacui	l     - \e[1mL\e[0mist Package Files"
			echo -e "  pacui	s     - \e[1mS\e[0mearch Package Files"
			echo
			echo -e "  pacui	b     - Roll \e[1mB\e[0mack System"
			echo -e "  pacui	fix   - \e[1mFix\e[0m Pacman Errors"
			echo -e "  pacui	c     - Edit \e[1mC\e[0monfig Files"
			echo -e "  \e[31mpacui	fu    \e[0m- \e[1mF\e[0morce \e[1mU\e[0mpdate System"
			echo -e "  \e[31mpacui	e     \e[0m- \e[1mE\e[0mmpty Package Cache"
			echo -e "  \e[31mpacui	fi    \e[0m- \e[1mF\e[0morce \e[1mI\e[0mnstall Packages"
			echo -e "  \e[31mpacui	fr    \e[0m- \e[1mF\e[0morce \e[1mR\e[0memove Packages"
			echo
			echo -e "  pacui	ua    - Force \e[1mU\e[0mpdate \e[1mA\e[0mUR"
			echo -e "  pacui	la    - \e[1mL\e[0mist Installed from \e[1mA\e[0mUR"
			echo
			echo -e "  pacui	ls    - \e[1mL\e[0mist Packages by \e[1mS\e[0mize"
			echo -e "  pacui	d     - \e[1mD\e[0mowngrade Packages"
			echo -e "  pacui	a     - Search + Install from \e[1mA\e[0mUR"
			echo
			echo -e "  pacui	h     - \e[1mH\e[0melp. For detailed help, please start User Interface first."
			
		else

			# if help file does not exist, create it
			if  [[ ! -e /tmp/pacui-help ]]
			then
			
				# this "heredoc" command pushes all the following lines into "cat" (and "cat pushed it to file /tmp/pacui-help) until a line with "EOF" is encountered
				cat > /tmp/pacui-help <<- "EOF"

\e[1mWelcome to PacUIs Help Page

PacUI is an interactive package manager for your command line terminal. It provides an easy user interface and uses Pacman and Pacaur/Yaourt as back ends. If Pacaur is installed on your system, PacUI uses it by default.

Navigate this help page with your Arrow Keys, PageUp/PageDown Keys, SpaceBar, or your Mouse Wheel. To search this Help Page, enter /<SEARCH TERM> and press ENTER. For example, enter the following (without quotes " ") in order to search for the word "update": "/update". Press "n" key to continue searching for "/update". Search is not case sensitive. To exit this Help Page, press your "q" key.
PacUI uses Fuzzy Finder (fzf) to display selectable lists, which can be easily searched by starting to type. Advanced users can even use regular expressions to search in fzf. Use your TAB key to select multiple items from the list and your ENTER key to choose your selection. Navigate fzf's list the same way you navigate this help page.


\e[1mHOME SCREEN
PacUI's home screen is split into three parts:
The first part focuses on updates, maintenance, installations, and removals of packages from system repositories. It includes useful tools for these actions, too.
The second part includes options for fixing your system. Options, which can break your system, are marked in red.
The last part offers options exclusive to Arch User Repository (AUR) management.


\e[1m00 - HELP
Display this help page. 
This help page only gets displayed when entered from PacUIs UI. If "pacui h" or "pacui -h" is executed in a terminal, a very short help page gets displayed. Quit this help page by pressing the "q" key.


\e[1m0 - QUIT
\e[36m"clear && exit"
This will clear your terminal and quit PacUI.


\e[1m1 - UPDATE SYSTEM
\e[36m"sudo pacman -Syu"
\e[36m"yaourt -Syua"
The first command compares a list of all installed packages with package database on your system repository mirror/server. If an updated package is available from your system repositories, it will get downloaded and installed on your system.
The second command does the same as the first part, but with one exception: It also downloads, compiles, and installs all packages from the Arch User Repository (AUR), which have an updated PKGBUILD file. The first command is still needed occasionaly, because major Pacman and Yaourt updates require "pacman -Syu" and will fail when started with Yaourt.
\e[1mAttention\e[0m: When a new version of an AUR package is available, sometimes the PKGBUILD file is not updated. If you want to install the latest version of a single AUR package, (re-)install it with INSTALL PACKAGES. If you want to install the latest versions of ALL AUR packages use FORCE UPDATE AUR.


\e[1m2 - MAINTAIN SYSTEM
\e[36m"sudo pacman-mirrors -f 0 && sudo pacman -Syy" \e[0m(for Manjaro)
This command generates a new mirrorslist of all available Manjaro repository mirrors/servers and sorts it by ping of up-to-date mirrors/servers. Additionally, the latest package database is downloaded from the chosen Manjaro repository mirror. If you want to speed up this command, it is recommended to only test your connection quality to Manjaro mirrors/servers near you. Example: You have noticed the pings to German and French mirrors are always best for you. Then, you can run: "sudo pacman-mirrors -c Germany,France".

\e[36m"sudo reflector -f 5 --sort age --save /etc/pacman.d/mirrorlist && sleep 20 && sudo pacman -Syy" \e[0m(for Arch and other Arch-based distros)
This command generates a new mirrorslist of all available repository mirrors/servers. Then it resyncs database to match the mirrors.

\e[36m"yaourt -Qdt"
This option lists all orphaned packages on your system. Orphaned packages are old and no longer needed dependencies (packages not explicitly installed by you), which were never removed from your system.

\e[36m"sudo pacdiff"
A .pacnew file may be created during a package upgrade to avoid overwriting a file (e.g. a config file) which already exists and was previously modified by the user. A .pacsave file may be created during a package removal, or by a package installation (the package must be removed first). When the pacman database has record that a certain file owned by the package should be backed up it will create a .pacsave file. These files require manual intervention from the user and it is good practice to handle them regularly. If left unhandled, improper configurations can result in improper function of the software, or the software being unable to run altogether. 
This command offers you a choice, whether you want to keep the original file (in most cases, these are config files) or the .pacnew/.pacsave file. Simply view both files by choosing "v". 
If you keep the original file, the program could not recognize the old syntax anymore, because it uses now a new syntax. In the worst case, your program could brake or stop working. If you remove the original file and use the new file without any changes, all your configurations might be reset to the default values. This can result in a changed system behavior, including removing passowrds or even sudo capability. 
In most cases, the syntax does not change and you can simply remove the new file (with the default configuration settings).
If you notice a syntax change, it is highly recommended to solve this conflict in another way (e.g. by manually editing one of those files and deleting the other).
\e[1mAttention\e[0m: This command requires a default file difference viewer by setting the environment variable DIFFPROG. If this varialbe is not set, a minimal default is provided by PacUI using "diff".
\e[1mAttention\e[0m: In severe and rare cases, removing your old config file (and using the new .pacnew config file) OR keeping your old config file (and deleting the .pacnew config file) can result in a broken system. PLEASE BE CAUTIOUS WHEN USING THIS COMMAND!

\e[36m"sudo find -xtype l -print" \e[0m(only if there are broken symlinks)
This command displays a list of broken symbolic links on your system. These links are not deleted by default. You have to decide yourself what to do with them. When you have doubt about deleting them, leave them on your system. They can sometimes cause problems, but they hardly use any hard drive space.

\e[36m"pacman -Dk"
This command checks your local package repository for consistency and shows missing packages, dependencies, or other errors. Please refer to "man pacman" for a more detailed explanation.

\e[36m"comm -23 <(pacman -Qqm | sort) <(curl https://aur.archlinux.org/packages.gz | gzip -cd | sort)"
This command compares 2 lists: The first list contains packages, which were not installed from your system repository. The second list contains all AUR package names. By comparing these 2 lists, it is possible to find EOL packages, which will never receive any updates.
These EOL packages can be either manually installed or they were initially installed from the AUR but have been removed from there in the meantime.
Unless you know exactly what you are doing, it is recommended to remove these EOL packages.

\e[36m"sudo journalctl --vacuum-size=50M --vacuum-time=30days"
This command limits all log files in journalctl to a combined size of 50 megabytes and a maximum age of 30 days. This leaves plenty of log files behind to analyze systematic and reoccuring errors while preventing excessive amounts of log files.

\e[36m"paccache -ruvk1"
\e[36m"paccache -rvk3"
By default Pacman uses this cache directory for downloading packages: /var/cache/pacman/pkg/... . No cached packages get deleted automatically. The package cache of an old and actively used installation can become quite large. Clean it to regain space on your root partition.
The first command removes all packages from cache, which are not installed (anymore) on your system, except the latest version. 
The second command removes all old packages from your cache except the 3 latest versions: The version you have currently installed on your system and 2 previous versions. Old package versions are kept to enable you to use ROLL BACK SYSTEM (or to manually downgrade packages) even without a working internet connection.

\e[36m"sudo pacman-optimize" \e[0m(only when installed on a HDD)
This command effectively defragments your Pacman database.
On traditional hard drives (HDD) this command can speed up all actions related to Pacman. 
\e[1mAttention\e[0m: It is NOT recommended to use this command on modern solid state hard drives (SSDs)!

\e[36m"mhwd-kernel -li"
\e[36m"mhwd-kernel -l" \e[0m(compare outputs of both commands for Manjaro only)
The first command outputs a list of <KERNEL NAME> of installed kernels on your system. 
The second command ouputs a list of <KERNEL NAME> of available and supported kernels by the Manjaro team.
By comparing both outputs, it is possible to extract a list of so called end-of-live kernels. These kernels are no longer supported and do not receive updates anymore. It is highly recommended to remove these kernels using Manjaro Settings Manager or the following command: "sudo mhwd-kernel -r <KERNEL NAME>"


\e[1m3 - INSTALL PACKAGES
\e[36m"yaourt -S <PACKAGE NAME>"
This option downloads and installs <PACKAGE NAME> on your system. The list of packages shows packages from your system repository with their description while package groups or packages from the AUR are only shown with their name.
\e[1mAttention\e[0m: Experienced users can install packages from the AUR without the need to answer questions all the time by using the command "yaourt -S <PACKAGE NAME> --noconfirm". The "--noconfirm" flag is great for quick and dirty installations of AUR packages on non-secure systems. Please keep always in mind that the AUR can contain any sort of package - including malicious and destructive (parts of) packages. Therefore, it is recommended to always check the PKGBUILD and .INSTALL file manually before installing a package from the AUR.


\e[1m4 - REMOVE PACKAGES + DEPS
\e[36m"sudo pacman -Rsn <PACKAGE NAME>"
This command removes <PACKAGE NAME> from your system including all dependencies, which are no longer needed by other packages. A copy of <PACKAGE NAME> will be kept in your package cache: Run MAINTAIN SYSTEM to remove it.
Please note that folders in your home (~) directory and created by the program <PACKAGE NAME> will not get removed from your system. Look for such folders in these places and remove them manually:
~/
~/.config/
~/.local/share/
\e[1mAttention\e[0m: If you want to display a list of all your installed packages (including their version number and description) use this PacUI option. Simply do not select <PACKAGE NAME> to be removed, but quit the list view with ESC or CTRL+C.


\e[1m5 - DEPENDENCY TREE
\e[36m"pactree -s <PACKAGE NAME>"\e[0m or \e[36m"pactree <PACKAGE NAME>"
This command will display a complete tree of all dependencies of <PACKAGE NAME>. <PACKAGE NAME> can be an installed package or a package from your system repositories. Dependencies are packages required by <PACKAGE NAME> in order to function. When you install <PACKAGE NAME>, all its dependencies get installed, too.
Please note that all selected lines (toggle selection with your TAB key) will get added to file /tmp/pacui-t.


\e[1m6 - REVERSE DEPENDENCY TREE
\e[36m"pactree -r <PACKAGE NAME>"
This command will display a tree of installed packages, which depend on <PACKAGE NAME>. In other words: All displayed packages require <PACKAGE NAME> in order to function (properly). 
Use this command when you want to know why you cannot remove <PACKAGE NAME> from your system.
Please note that all selected lines (toggle selection with your TAB key) will get added to file /tmp/pacui-rt.


\e[1m7 - LIST PACKAGE FILES
\e[36m"pacman -Ql <PACKAGE NAME>"
\e[36m"sudo pacman -Fyl <PACKAGE NAME>" \e[0m(only for packages not installed on your system)
These commands list all files contained in <PACKAGE NAME> including their path. The second command syncs the file database with your system repositories and then searches the file database for files, which get installed by <PACKAGE NAME>.
As a result the complete path to the files gets displayed.
Have you ever installed a program and did not know with which command it can be started/executed? Just look for files (and their names) in your /usr/bin/ directory using LIST PACKAGE FILES.
By default, the results are filtered for files located in usr/bin/, but you can enter any filter term you want to. Delete the default filter term with BACKSPACE to see a complete list of files of <PACKAGE NAME>. Please note that all selected lines (toggle selection with your TAB key) will get added to file /tmp/pacui-l.
\e[1mAttention\e[0m: On some systems, the file database has not been downloaded which results in an error message instead of search results from your system repositories. You can fix it by running "sudo pacman -Fyy" once and restarting LIST PACKAGE FILES.


\e[1m8 - SEARCH PACKAGE FILES
\e[36m"pacman -Ql | grep <FILE NAME>"
\e[36m"sudo pacman -Fysx <FILE NAME>" \e[0m(only for packages not installed on your system)
In some situations, Pacman (e.g. during UPDATE SYSTEM) cannot find a file, for example a shared library. An error message is shown about <FILE NAME>. Use SEARCH PACKAGE FILES to find out, which package has installed <FILE NAME>. In most cases, you can fix the Pacman error by using one of the following options on that package: UPDATE SYSTEM, ROLL BACK SYSTEM, FORCE REMOVE PACKAGES and INSTALL PACKAGES, or FORCE UPDATE SYSTEM.
SEARCH PACKAGE FILES is in many ways a reverse LIST PACKAGE FILES. You can use it to find out which package you have to install in order to use the <FILE NAME> command in your terminal.
The first command searches for <FILE NAME> in all your installed packages. <FILE NAME> can be only a part of an actual file name or contain regular expressions.
The second command syncs the file database with your system repositories and then searches the file database for <FILE NAME>.
As a result, <REPOSITORY>/<PACKAGE NAME> and the complete path to <FILE NAME> gets displayed using fzf. <PACKAGE NAME> is always printed in a bold font. <REPOSITORY> only gets displayed for packages, which are not installed on your system. Please note that all selected lines (toggle selection with your TAB key) will get added to file /tmp/pacui-s.
\e[1mAttention\e[0m: On some systems, the file database has not been downloaded which results in an error message instead of search results from your system repositories. You can fix it by running "sudo pacman -Fyy" once and restarting SEARCH PACKAGE FILES.


\e[1m9 - ROLL BACK SYSTEM
\e[36m"sudo pacman -Rdd <PACKAGE NAME> --noconfirm" \e[0m(only for rolling back package installations)
\e[36m"sudo pacman -U <PACKAGE NAME IN PACMAN/PACAUR CACHE> --noconfirm" \e[0m(only for rolling back package removals, upgrades, or downgrades.)
Manjaro and Arch Linux use a rolling release development model. This means ALL packages on your system continuously get updated to the latest version. Sometimes, things go wrong during UPDATE SYSTEM and you should roll back the last update. In case the latest version of a single package is broken, rolling back (a.k.a. downgrading) that package can work.
This command shows you a list of all recent Pacman actions sorted by date (using parts of this command: "tail -5000 /var/log/pacman.log"). Please select all Pacman actions you want to roll back. Installed packages will be removed from your system. Removed packages will be reinstalled as the latest version available in your Pacman/Pacaur cache. Upgraded packages will be downgraded to the previous version (if this version is available in your local Pacman/Pacaur cache). Downgraded packages will be Upgraded to a later version. If you select multiple upgrades/downgrades of the same package, the package gets downgraded/upgraded multiple times (if this version is available in your local Pacman/Pacaur cache).
\e[1mAttention\e[0m: It is strongly recommended to always roll back <PACKAGE NAME> including ALL its dependencies. Otherwise, your system could be left in a broken state. If you are in doubt about that, rolling back all changes made on your system in a short time intervall should be sufficient.
\e[1mAttention\e[0m: After downgrading a broken package to a working version, it is recommended to add the package name to your Ignore List ( "IgnorePkg" option in /etc/pacman.conf ). This will prevent Pacman from showing any available updates for this package. The package needs to be removed manually from your Ignore List in order to receive automatic updates again. Alternatively, you can run future updates with the command "sudo pacman -Syu --ignore <PACKAGE NAME>" until a fixed version of that package gets released.


\e[1m10 - FIX PACMAN ERRORS
Multiple commands attempt to fix the most common issues Manjaro users have with Pacman. This should also work for Arch-based distributions, but to a lesser degree. Force options (as in FORCE UPDATE SYSTEM) are excluded, even though they are essential in fixing some problems.
Please make sure that your root partition is not full. If you have doubts about this, run MAINTAIN SYSTEM before FIX PACMAN ERRORS.
A working internet connection is required for FIX PACMAN ERRORS!

\e[36m"sudo rm -f /var/lib/pacman/db.lck"
This command removes Pacmans database lock. The database lock prevents multiple Pacman instances from running at the same time and interfering with each other.
\e[1mAttention\e[0m: Only run this command when no other Pacman instance (e.g. Pacman, Yaourt, Pamac, Octopi, PacmanXG4, ...) is running.

\e[36m"sudo pacman-mirrors -f 0 && sudo pacman -Syy" \e[0m(for Manjaro)
This command generates a new mirrorslist of all available Manjaro repository mirrors/servers and sorts it by ping of up-to-date mirrors/servers. Additionally, the latest package database is downloaded from the chosen Manjaro repository mirror. If you want to speed up this command, it is recommended to only test your connection quality to Manjaro mirrors/servers near you. Example: You have noticed the pings to German and French mirrors are always best for you. Then, you can run: "sudo pacman-mirrors -c Germany,France".

\e[36m"sudo reflector -f 5 --sort age --save /etc/pacman.d/mirrorlist && sleep 20 && sudo pacman -Syy" \e[0m(For Arch and other Arch-based distros)
This command generates a new mirrorslist of all available repository mirrors/servers. Then it resyncs database to match the mirrors.

\e[36m"sudo dirmngr </dev/null"
Sometimes during key management the package "dirmngr" outputs error messages, which interrupt key management processes (such as the following commands). This command prevents any output from "dirmngr".

\e[36m"sudo sed -i 's/SigLevel[ ]*=/SigLevel = Never #/' /etc/pacman.conf "
The following commands delete and reinstall some essential packages. If your keyring is broken, no packages could be installed because of a key mismatch. Therefore, it is important to disable Pacman's key check before continuing.
This command disables the signature key check of packages by Pacman.

\e[36m"sudo systemctl stop ntpd.service"
This command stops (temporarily) the Network Time Protocol daemon service NTPD (if it is installed and running). In case NTPD is not installed, the output is ignored.
This is the first command of a series of commands, which try to set the system and hardware clock on your computer (ignoring time zone and daylight saving time). An (almost) correct system time is needed for checking and importing keys or fingerprints later on in the fixing process!

\e[36m"sudo pacman -Sy networkmanager-dispatcher-ntpd"
This command (re-)installs the "networkmanager-dispatcher-ntpd" package. PacUI actually does not use this command but instead downloads and installs this package manually in order to bypass key database and key chain errors.
\e[1mAttention\e[0m: PacUI will fail if you cannot install any packages on your system anymore due to key database and key chain errors AND "networkmanager-dispatcher-ntpd" was not installed on your system before. As long as your system clock is set (almost) correct, you do not have to worry about it. But if your system clock is set completely wrong AND you cannot install any packages on your system anymore AND "networkmanager-dispatcher-ntpd" was not installed on your system before, you have to set your system clock manually before you run PacUIs "fix" command. You can do this with the following command:
sudo timedatectl set-time "yyyy-MM-dd hh:mm:ss"
( example: sudo timedatectl set-time "2016-05-26 11:13:54" )

\e[36m"sudo ntpd -qg && sleep 60 && sudo hwclock -w"
The first command starts the just (re-)installed Network Time Protocol daemon (ntpd.service). Next, your system clock is set. Finally, the ntpd.service is quit.
The second command makes your system wait for 60 seconds. This is done as precaution to ensure your system has enough time to connect to an internet or network server and set the system clock.
The third command is only run when the first and second command have been successfully finished. It writes the time from your system clock to your hardware clock.
\e[1mAttention\e[0m: The last command is needed in order to prevent another services on your system to set your system clock according to your hardware clock in regular intervals. This may result in a hardware clock, which is not set to UTC anymore and/or a system clock, which shows the wrong time. If you encounter this problem read the Arch Linux Wiki article about time: "https://wiki.archlinux.org/index.php/Time"

\e[36m"sudo rm -r /etc/pacman.d/gnupg"
This command deletes your key database. It does not output an error in case the package "gnupg" is not installed on your system.
\e[1mAttention\e[0m: This command will remove all keys from your system, including manually installed keys (with "sudo pacman-key --lsign-key <KEY>"). Please remember to reinstall those keys again after FIX PACMAN ERRORS has completed!

\e[36m"sudo pacman -Sy gnupg $(pacman -Qsq '(-keyring)' | grep -v -i -E '(gnome|python|debian)' | paste -sd " " )"
This command (re-)installs the gnupg and keyring packages. PacUI actually does not use this command but instead downloads and installs this package manually in order to bypass key database and key chain errors.

\e[36m"sudo sed -i 's/SigLevel = Never #/SigLevel =/' /etc/pacman.conf "
This command enables the signature check of packages by Pacman again.
\e[1mAttention\e[0m: If this command fails or the PacUI script is exited after the signature check has been disabled and this command, it is highly recommended to manually check your /etc/pacman.conf file and remove all "Never #" strings you can find. Only by doing this, you can trust package installations on your system again!

\e[36m"sudo pacman-key --init && sudo pacman-key --populate $(pacman -Qsq '(-keyring)' | grep -v -i -E '(gnome|python|debian)' | sed 's/-keyring//' | paste -sd " " )"
These two commands create a fresh key for you and import and (re-)install all keyrings. This will solve problems with your local key database and your distro's and Arch's key database. Such problems can occur when new new Arch Linux or your distro packagers get added, for example.
\e[1mAttention\e[0m: This command might take a long time to complete. If your system appears to stop or hang, it searches for entropy in order to generate a new key for you. In this case, it might help to do file operations with a lot of reads and/or writes per minute (such as searching for files, copying large directories, etc.). Alternatively, you can open a browser and do some heavy surfing (with a lot of mouse movements, mouse klicks, and keyboard key presses): This can help to generate entropy much faster.

\e[36m"echo 'keyring /etc/pacman.d/gnupg/pubring.gpg' >> $HOME/.gnupg/gpg.conf"
There are 2 different places in Arch Linux and Manjaro to store keys: One place is used by pacman and the other gets used by GPG. 
This command imports all keys for Pacman into GPG. This essentially means that the user trusts all Arch Linux Trusted Users and your distro's developers. After that, you will be able to install AUR packages from Arch Linux Trusted Users and your distro's developers without the need to import those keys manually.

\e[36m"sudo pacman -Sc"
After an unseccessful attempt to update your system (which quit with a key error), you might have already downloaded unsigned packages to your pacman cache. These packages cannot be installed anymore.
This command removes all packages from your pacman cache, which are not installed on your system. Afterwards, you need to download all previously downloaded but not installed packages again.
\e[1mAttention\e[0m: This command makes it impossible to ROLL BACK SYSTEM on systems without an internet connection.

\e[36m"sudo pacman -S --needed libsystemd systemd-sysvcompat systemd && sleep 30"
The first command updates - if necessary - systemd including important components before all other packages are updated. This is necessary, because sometimes a successful update of systemd causes a short crash on some systems, which prevents a successful update of all other packages.
The second command simply does nothing for 30 seconds before the update of all other packages get started. It is only here as precaution.

\e[36m"sudo pacman -Syyuu"
This last command forces a redownload of the latest package database from the best repository mirror. Then, all your installed packages are checked against this latest package database. If an updated package is available from your system repositories, it will get downloaded and installed on your system. If an installed package is newer than the same package in your system repositories, the installed package will get downgraded. This behavior ensures your packages are always in sync with your system repositories, even if you have just switched the repository mirror or switched from branches.

\e[36m"sudo pacman -Suu"
This command makes abolutely sure all downloaded packages get installed and downgraded if necessary. The user has to manually allow downgrades of packages, if downgrades are available.

\e[36m"sudo pacman -Fyy"
This command forces a sync of the file database of your system repository with your used repository mirror server. The file database is separate from the package database. The file database enables SEARCH PACKAGE FILES and LIST PACKAGE FILES of packages, which are not installed on your system but only available on your system repository.


\e[1m11 - EDIT CONFIG FILES
\e[36m"$EDITOR <FILE NAME>"
This command opens <FILE NAME> in your default text editor. You can choose between multiple important system configuration files. Files in the root directory are opened with root privileges.
By default the text editor Nano gets used, except a custom $EDITOR variable has been exported. In the text editor Nano, Press CTRL+O to save your changes, ENTER to choose a directory, and CTRL+X to quit Nano.
\e[1mAttention\e[0m: Changing system configuration files can harm or even destroy your system. In some cases, this can happen with a single mistake. Be extremely careful and always double check your changes before saving and rebooting - especially when editing the files marked in red! It is recommended to search the Arch Wiki for the configuration file you want to edit and read about available and recommended settings.


\e[1;31m13 - FORCE UPDATE SYSTEM
\e[36m"sudo pacman -Syu --force"
This command does the same as UPDATE SYSTEM, but it bypasses file conflict tests and overwrites conflicting files. All files will be overwritten. 


\e[1;31m14 - EMPTY PACKAGE CACHE
\e[36m"yaourt -Scc"
This command will empty your entire package cache by deleting ALL packages.
\e[1mAttention\e[0m: This will make it impossible to ROLL BACK SYSTEM without a working internet connection.


\e[1;31m15 - FORCE INSTALL PACKAGES
\e[36m"sudo pacman -S --force <PACKAGE NAME>"
This command does the same as INSTALL PACKAGES for packages from your system repositories exclusively. The installation of <PACKAGE NAME> is forced.


\e[1;31m16 - FORCE REMOVE PACKAGES
\e[36m"pacman -Rdd <PACKAGE NAME>"
This command removes <PACKAGE NAME> without checking the dependencies of <PACKAGE NAME> first. This enables experienced users to remove packages and dependencies of packages. This command only removes <PACKAGE NAME> from your system. All dependencies and orphans are left: run MAINTAIN SYSTEM afterwards to remove them.
\e[1mAttention\e[0m: This command can break pacakges on your system or even your entire system.


\e[1m17 - FORCE UPDATE AUR
\e[36m"yaourt -Syua && yaourt -Syua --devel --needed --noconfirm"
The Arch User Repository (AUR) is a repository of (mostly) PKGBUILD files. Everybody can create such a PKGBUILD file and upload it to the AUR. A PKGBUILD file contains simple and human readable instructions like where to download the source code from, what dependencies are needed, where to copy files for installation, etc. Yaourt is a so called AUR Helper: It can interpret PKGBUILD files and download the source code, install dependencies, build files on your system, and copy these files to the right location (a.k.a. installing a program).
By checking a PKGBUILD file (and .INSTALL file) you can make sure the source code is loaded from an official download server, no harmful dependencies get installed, and the installation instructions do not contain harmful code.
A lot of PKGBUILD files contain variables (e.g. program version) in download addresses; this makes them download always the latest source code (e.g. from Github) during installation. Some PKGBUILD files contain no variables: These PKGBUILD files need to be changed manually every time a new program version is released.
The first command of FORCE UPDATE AUR does the same as the second command of UPDATE SYSTEM: Only AUR packages with updated/changed PKGBUILD files will get updated. This gives you the chance to check these updated/changed PKGBUILD files. 
The second command of FORCE UPDATE AUR forces a reinstall of ALL your developmental AUR packages (i.e. all git, svn, and cvs-packages). These kinds of AUR packages are usually never updated/reinstalled with a simple "yaourt -Syua". The "--noconfirm" flag is used in a secure way, because no PKGBUILD files have changed since the first command got executed.
\e[1mAttention\e[0m: This might take a long time! When using Yaourt, after every 15min this command will pause and ask again for your password.


\e[1m18 - LIST INSTALLED FROM AUR
\e[36m"pacman -Qm"
This command lists all installed packages, which are from the AUR or which were manually installed. Please note that all selected lines (toggle selection with your TAB key) will get added to file /tmp/pacui-la.
If you want a list of all installed packages use REMOVE PACKAGES + DEPS as described in this Help Page.


\e[1mLIST PACKAGES BY SIZE
\e[36m"expac -Q '%m - %n %v' | sort -n -r "
This command lists packages on your system sorted by their installation size. Both explicitly installed packages and dependencies are displayed. Important system packages part of the "base" or "base-devel" group are not displayed. Please note that all selected lines (toggle selection with your TAB key) will get added to file /tmp/pacui-ls.


\e[1mDOWNGRADE PACKAGES
\e[36m"downgrade <PACKAGE NAME>"
Manjaro and Arch Linux use a rolling release development model. This means ALL packages on your system continuously get updated to the latest version. If the latest version of a packages does not work on your system, you can downgrade that package to an earlier, working version.
This command downgrades <PACKAGE NAME> and offers you a list of old <PACKAGE NAME> versions to choose from. This list includes all old <PACKAGE NAME> versions from your local package cache and online sources (if you have a working internet connection). 
After a successful downgrade, you can add <PACKAGE NAME> to your Ignore List ( "IgnorePkg" option in /etc/pacman.conf ). This will prevent Pacman from showing any available updates for <PACKAGE NAME>. <PACKAGE NAME> needs to be removed manually from your Ignore List in order to receive automatic updates of <PACKAGE NAME> again.
Alternatively, you can run future updates with the command "sudo pacman -Syu --ignore <PACKAGE NAME>" until a fixed version of <PACKAGE NAME> gets released.
\e[1mAttention\e[0m: Be careful when using Manjaro and downgrading to <PACKAGE NAME> from online sources, because these are old versions from the Arch Linux repositories only: In the worst case, this can brake your system! Therefore, it is recommended to limit downgrading to (old versions of) local packages, if possible.
\e[1mAttention\e[0m: Downgrading to a working version of <PACKAGE NAME> can break your system in in rare cases like the following: The latest system update has replaced a dependency of <PACKAGE NAME> with a different package and <PACKAGE NAME> is an important system package. Downgrading <PACKAGE NAME> will NOT reinstall the dependency of <PACKAGE NAME>, because it conflicts with the already installled different package. This can result in a broken system. Please keep these kind of conflicts in mind when using DOWNGRADE PACKAGES.
\e[1mAttention\e[0m: DOWNGRADE PACKAGES will show you a selection of packages you can downgrade. If you are using Pacaur to install AUR packages, you will not be able to downgrade AUR pacakges using DOWNGRADE PACKAGES! instead, the ROLL BACK SYSTEM option is recommended.


\e[1mSEARCH + INSTALL FROM AUR
\e[36m"yaourt <PACKAGE NAME>"
This command searches for <PACKAGE NAME> in all system repositories and the Arch User Repository (AUR). It searches for package names and package descriptions. 
Example: You can search for "web browser" and you will find Firefox and other web browsers. One or multiple search results can be installed on your system.
If you want to exit this mode without installing any packages, simply press CTRL+C or ENTER.



Press "q" to quit this Help Page.

				EOF
			
			fi

			# display /tmp/pacui-help file in "less" and interpret all ANSI escape sequences in it (which only works with "echo -e ..."
			echo -e "$( cat '/tmp/pacui-help' )" | less -RMi
			
		fi
}


# all functions of pacui end here.

# =======================

# section for general bug fixes


# bug #2:
# when used with tmux and pacaur and $EDITOR variable is not set and vi is not installed ("vi" is the default editor used by pacaur): 
# pacaur sometimes does not find an editor to use and the --preview window in fzf does not show any package information.
# instead, it shows "::editor variable unset".

# check, whether pacaur is installed, user config file exists, $EDITOR variable is empty, "vi" is not installed:
if [[ -e /usr/bin/pacaur ]] && [[ ! -e $XDG_CONFIG_HOME/pacaur/config ]] && [[ ! -n $EDITOR ]] && [[ ! -e /usr/bin/vi ]]
then
    # export "editor='${EDITOR:-nano}'" to config file. '${EDITOR:-nano}'" outputs "nano", if there is no $EDITOR variable set.
	mkdir -p $XDG_CONFIG_HOME/pacaur/
    echo "editor='${EDITOR:-nano}'" >> $XDG_CONFIG_HOME/pacaur/config
fi


# =======================


# the following section of code gets executed when this script gets called directly from a terminal/tty without using the UI:


# write first argument of "pacui ..." (= option of pacui) to "input" variable.
input=$1
# wirte all other arguments of "pacui $1 ..." (= often (parts of) package or file names) to "input2" variable. all arguments gets combined into one variable with spaces, but no breaks. 
# fzf will always display search results for "input2", if it exists (and "input" is a valid function"). if "input2" is not found in fzf's list, NOTHING is displayed.
input2=${*:2}

# if "input" starts with a "-" or "--" dash symbol, the dash(es) gets removed from the beginnig of "input" variable
input=${input#-}
input=${input#-}

# convert content of "input" variable to lowercase
input=$( echo "$input" | tr '[:upper:]' '[:lower:]' )


# the following code checks, whether a prefix (func_) + varialbe "input" is a valid function defined above. after the function is done an "exit" command is needed to prevent the UI from loading.
if [[ $( type -t "func_$input") == "function" ]] 
then
		
		"func_$input" 1		# pass the parameter "1" with the funciton when it gets called directly from terminal.
		
		unset input
		unset input2
		
		exit $?			# exit here and return error code if present
		
elif (( $# > 0 ))		# if "func_$input" is no valid function AND if one or more arguments are given. this condition is needed to exclude "pacui" (without any arguments) from running this section.
then
		
		unset input
		unset input2
		
		# error, if $input does not refer to a valid function. the UI will be started by default.
		echo -e "Bad console command. Press ENTER to start PacUI or CTRL+C to abort."
		read
		# now, continue this script without exiting.
		
fi


# logic code is above
# =======================
# =======================
# =======================
# UI code is below

# section for bug fixes related to UI:


# bug #1:
# the traditional "clear" command does not work as expected on all systems. solution: do everything i expect from "clear" manually:
function pacui_clean 
{
		# number of lines of the user's terminal.
		lines=$( tput lines )
		for (( i=1; i<=lines; i++ ))
		do
				# insert "lines" number of empty lines:
				echo
		done
		# move cursor to the top left of the terminal
		tput cup 0 0
}


# =======================


# Run infinte loop for UI / menu, till the user quits using the "quit" option or CTRL+C.
while true
do
	
	pacui_clean
	
	# draw UI / menu. please note the use of ANSI Escape sequences mentioned above. The text/code can be hard to read...
	echo
	echo -e "                       \e[7m PacUI - Package manager \e[0m                      "
	echo -e " ┌───────────────────────────────────────────────────────────────────┐"
	echo -e " │    1   \e[1mU\e[0mpdate System               2   \e[1mM\e[0maintain System            │"
	echo -e " │    3   \e[1mI\e[0mnstall Packages            4   \e[1mR\e[0memove Packages + Deps     │"
	echo -e " │-------------------------------------------------------------------│"
	echo -e " │    5   Dependency \e[1mT\e[0mree             6   \e[1mR\e[0meverse Dependency \e[1mT\e[0mree    │"
	echo -e " │    7   \e[1mL\e[0mist Package Files          8   \e[1mS\e[0mearch Package Files       │"
	echo -e " └───────────────────────────────────────────────────────────────────┘"
	echo -e "      9   Roll \e[1mB\e[0mack System           10   \e[1mFix\e[0m Pacman Errors "
	echo -e "     11   Edit \e[1mC\e[0monfig Files "
	echo -e "   \e[31m  13   \e[1mF\e[0;31morce \e[1mU\e[0;31mpdate System        14   \e[1mE\e[0;31mmpty Package Cache       \e[0m "
	echo -e "   \e[31m  15   \e[1mF\e[0;31morce \e[1mI\e[0;31mnstall Packages     16   \e[1mF\e[0;31morce \e[1mR\e[0;31memove Packages     \e[0m "
	echo -e " ┌───────────────────────────────────────────────────────────────────┐"
	echo -e " │   17   Force \e[1mU\e[0mpdate \e[1mA\e[0mUR           18   \e[1mL\e[0mist Installed from \e[1mA\e[0mUR    │"
	echo -e " └───────────────────────────────────────────────────────────────────┘"
	echo
	echo -e "  Enter number or marked letter(s)      -   00   \e[1mH\e[0melp   -    0   \e[1mQ\e[0muit "

	# save entered numbers/letters in varialbe "choice"
	read -r choice
	# convert "choice" variable to lowercase:
	choice=$(echo "$choice" | tr '[:upper:]' '[:lower:]' )
	echo
	
	# test, whether "choice" fits any of the following numbers, letters, or words
	case $choice in


		# this line means: the following commands will get executed if $choice is "1" or "u" or "update" until a ";;" code line is encountered:
		1|u|update )
			# call function "func_u"
			func_u
			echo
			echo " System updated. To return to PacUI press ENTER "
			# wait for input, e.g. by pressing ENTER:
			read
			;;
		2|m|maintain )
			func_m
			echo
			echo " System maintenance finished. To return to PacUI press ENTER "
			read
			;;
		3|i|install )
			func_i
			echo
			echo " Package installation finished. To return to PacUI press ENTER "
			read
			;;
		4|r|remove )
			func_r
			echo
			echo " Package(s) including all unneeded dependencies removed. To return to PacUI press ENTER "
			read
			;;
		5|t|tree )
			func_t
			echo
			;;
		6|rt|reversetree )
			func_rt
			echo
			;;
		7|l|list )
			func_l
			echo
			;;
		8|s|search )
			func_s
			echo
			;;


		9|b|back )
			func_b
			echo
			echo " System roll back finished. To return to PacUI press ENTER "
			read
			;;
		10|fix )
			func_fix
			echo
			echo " Operation finished. To return to PacUI press ENTER "
			read
			;;
		11|c|conf|config )
			func_c
			echo
			echo " Configuration files edited. To return to PacUI press ENTER "
			read
			;;
		13|fu|forceupdate )
			func_fu
			echo
			echo " System updated in force mode. To return to PacUI press ENTER "
			read
			;;
		14|e|empty )
			func_e
			echo
			echo " Entire package cache emptied. To return to PacUI press ENTER "
			read
			;;
		15|fi|forceinstall )
			func_fi
			echo
			echo " Package installation in force mode finished. To return to PacUI press ENTER "
			read
			;;
		16|fr|forceremove )
			func_fr
			echo
			echo " Package(s) removed in force mode. To return to PacUI press ENTER "
			read
			;;


		17|ua|fua|forceupdateaur|updateaur )
			func_ua
			echo
			echo " All AUR packages updated and reinstalled. To return to PacUI press ENTER "
			read
			;;
		18|la|listaur )
			func_la
			echo
			;;


		ls|listsizes )
			func_ls
			echo
			;;
		d|down|downgrade )
			func_d
			echo
			echo " Downgrade finished. To return to PacUI press ENTER "
			read
			;;
		a|aur )
			func_a
			echo
			echo " Installation from AUR finished. To return to PacUI press ENTER "
			read
			;;


		00|h|help )
			func_h
			echo
			;;
		0|q|quit|$'\e'|$'\e'$'\e' )
			pacui_clean && exit
			;;


		* )
			echo -e " \e[41m Wrong option \e[0m"
			echo -e "  Please try again...  "
			sleep 2
			;;


	esac    # close case-loop
done        # close while-loop
